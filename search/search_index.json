{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Material for MkDocs","text":"<p>Welcome to Material for MkDocs.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2016-2025 Martin Donath</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"repoFer/API%20folder%20tree/","title":"Aixt API folder tree v0.1.2","text":"<p>The Aixt API for each microcontroller port has to be located in the folder:</p> <pre><code>aixt/ports/brand/microcontroller_or_board/api\n</code></pre> <pre><code>aixt/ports/brand/brand/microcontroller_or_board/api\n</code></pre> <p>for instance:</p> <pre><code>aixt/ports/Microchip/Explorer-16/PIC24/api\n</code></pre> <pre><code>aixt/ports/Emulator/api\n</code></pre> <p>All the API implementations have to follow this basic folder tree:</p> <pre><code>ports/Microchip/Explorer-16/PIC24/api/\n\u251c\u2500\u2500 builtin.c\n\u251c\u2500\u2500pin\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pin.c\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 setup.c\n:   :\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 high.c\n:\n\u2514\u2500\u2500 time\n    \u251c\u2500\u2500 sleep.c\n    \u251c\u2500\u2500 sleep_ms.c\n    \u2514\u2500\u2500 sleep_us.c\n</code></pre> <p>starting from the Aixt project main folder.</p> <p>The Aixt API is composed by several modules with certain microcontroller functionality. All the API functions referring to the available inner hardware or peripherals of each microcontroller are located in the module named as the peripheral, for instance <code>adc</code>. Other functions referring to generic functionalities are located in a respective module named according them. For example, all the functions referring to time or delaying are located in the <code>time</code> module.</p> <p>In order to follow the V language syntactic rules, all the folder and file names inside the api folder must use snake_case.</p>"},{"location":"repoFer/API%20folder%20tree/#modules","title":"Modules","text":"<p>Each module in the API have to be implemented by means of a C's files in the module_name/ folder. For example, the <code>time</code> module is implemented in <code>time/</code> as follows: </p> <pre><code>api\n \u251c\u2500\u2500 ...\n :\n \u2514\u2500\u2500 time\n  \u00a0   \u251c\u2500\u2500 sleep_ms.c\n  \u00a0   \u2514\u2500\u2500 sleep_us.c\n</code></pre>"},{"location":"repoFer/API/","title":"Aixt Application Programming Interface v0.1.2","text":""},{"location":"repoFer/API/#digital-io-pins","title":"Digital I/O (Pins)","text":"<p>requires:</p> <pre><code>import pin\n</code></pre>"},{"location":"repoFer/API/#pin-setup","title":"Pin setup","text":"<pre><code>pin.setup(name, mode)\n</code></pre> <ul> <li><code>name</code> could change depending on the microcontroller for instance <code>pin.b7</code>, <code>pin.gp7</code>, etc.</li> <li><code>mode</code>:</li> <li><code>pin.input</code></li> <li><code>pin.output</code></li> </ul>"},{"location":"repoFer/API/#pin-output","title":"Pin output","text":"<pre><code>pin.high(name)\n</code></pre> <pre><code>pin.low(name)\n</code></pre> <pre><code>pin.toggle(name)    \n// not available for all devices\n</code></pre> <pre><code>pin.write(name, value)\n</code></pre> <ul> <li><code>value</code> is an integer to be written in the pin</li> <li><code>0</code></li> <li><code>1</code></li> </ul>"},{"location":"repoFer/API/#pin-input","title":"Pin input","text":"<pre><code>x = pin.read(name)\n</code></pre> <p><code>pin.read()</code> returns an integer (<code>0</code> or <code>1</code>)</p>"},{"location":"repoFer/API/#analog-to-digital-converter-adc-inputs","title":"Analog to Digital Converter (ADC inputs)","text":"<p>requires:</p> <pre><code>import adc\n</code></pre> <p>The syntax for all the ADC functions is: <code>adc.function_name()</code>.</p>"},{"location":"repoFer/API/#adc-setup","title":"ADC setup","text":"<pre><code>adc.setup(setup_value_1, setup_value_2, ... )   // equals to adc1_setup(...)\n</code></pre>"},{"location":"repoFer/API/#adc-reading","title":"ADC reading","text":"<pre><code>x = adc.read(channel)\n</code></pre> <ul> <li><code>channel</code> is an identifying number of the ADC input, for instance <code>adc.ch3</code></li> </ul>"},{"location":"repoFer/API/#pulse-width-modulation-pwm-outputs","title":"Pulse Width Modulation (PWM outputs)","text":"<p>requires:</p> <pre><code>import pwm\n</code></pre> <p>The syntax for all the PWM functions is: <code>pwm_function_name()</code>.</p>"},{"location":"repoFer/API/#pwm-setup","title":"PWM setup","text":"<pre><code>pwm_setup(setup_value_1, setup_value_2, ... )  //or just pwm.setup(...)\n</code></pre>"},{"location":"repoFer/API/#pwm-duty-cycle","title":"PWM duty cycle","text":"<pre><code>pwm.write(channel, duty)  //or pwm1_duty(duty)\n</code></pre> <ul> <li><code>duty</code> is the duty cycle (8-bit number in most of devices)</li> <li><code>channel</code> is th output or channel name, for instance <code>pwm.ch1</code></li> </ul>"},{"location":"repoFer/API/#serial-communication-uart","title":"Serial communication (UART)","text":"<p>requires:</p> <pre><code>import uart\n</code></pre> <p>The default UART could change depending on the board or microcontroller, please refer to the specific documentation. The syntax for most of UART functions is: <code>uartx.function_name()</code>, being <code>x</code> the identifying number in case of multiple UARTs. You can omit the <code>x</code> for referring to the first or default UART, or in the case of having only one.  </p>"},{"location":"repoFer/API/#uart-setup","title":"UART setup","text":"<pre><code>uart.setup(baud_rate)   // the same of uart1_setup(baud_rate)\n</code></pre> <ul> <li><code>baud_rate</code> configure the communication speed</li> </ul>"},{"location":"repoFer/API/#serial-receiving","title":"Serial receiving","text":"<pre><code>str1 = uart.input()          // read a string from the default UART\n</code></pre> <pre><code>str2 = uart2.input()    // read a string from UART2\n</code></pre> <pre><code>str2 = uart1.read()    // read a single Byte from UART1\n</code></pre>"},{"location":"repoFer/API/#serial-transmitting","title":"Serial transmitting","text":"<pre><code>uart.print(message)      // print a string to the default UART\n</code></pre> <pre><code>uart.println(message)    // print a string plus a line-new character to the default UART\n</code></pre> <pre><code>uart2.print(message)    // print a string to the UART2\n</code></pre> <pre><code>uart3.println(message)  // print a string plus a line-new character to the UART3\n</code></pre> <pre><code>uart2.write(message)    // send binary data (in Bytes) to UART2\n</code></pre>"},{"location":"repoFer/API/#delay","title":"Delay","text":"<p>requires:</p> <pre><code>import time\n</code></pre> <pre><code>time.sleep(s)    // delay in seconds\n</code></pre> <pre><code>time.sleep_ms(ms)    // delay in milliseconds\n</code></pre> <pre><code>time.sleep_us(us)    // delay in microseconds\n</code></pre>"},{"location":"repoFer/API/#creating-a-new-api-module","title":"Creating a new API module","text":""},{"location":"repoFer/API/#file-function_namecv","title":"File <code>function_name.c.v</code>.","text":"<p>All functions implemented in each Aixt module have a file named:  <code>function_name.c.v</code> where it is done its implementation.</p> <p>For instance the <code>setup</code> function of the <code>adc</code> module, which sets the resolution of the ADC, has to be described in <code>adc/setup.c.v</code>.</p> <p>In devices using the arduino backend most functionalities just have to be masked instead of implementing them from scratch. In this case the <code>setup</code> function in V masks the <code>analogReadResolution</code> function of arduino.</p> <p>All functions have to be public (<code>pub</code>).</p> <p>The <code>@[inline]</code> attribute is optional and defines the function created in C to be <code>inline</code>.</p>"},{"location":"repoFer/API/#file-module_namecv","title":"File <code>module_name.c.v</code>.","text":"<p>All modules implemented in the <code>api</code> directory have a file with the same name as the module. For example the <code>pwm</code> module must have a <code>pwm.c.v</code> file where the basic definitions for the module are made.</p> <p>In this case the functions to be invoked from C (arduino) are defined.</p> <p>V allows the <code>any</code> data type which is practical if the return data type and/or parameters of the function to be masked are not known.</p> <p>In this case the implementation can be left as is.</p>"},{"location":"repoFer/API/#file-inclusion-in-c","title":"File inclusion in C","text":"<p>API modules in Aixt can include <code>.c</code> or <code>.h</code> files with the <code>#include &lt;lib.h&gt;</code> or <code>#include \u201clib.h\u201d</code> directive. Note that files enclosed in <code>\"</code> will be searched in the same directory.</p>"},{"location":"repoFer/API/#masking-of-arduino-methods","title":"Masking of arduino methods","text":"<p>In the case of the arduino backend, functions defined as methods can be redefined as macros in a <code>.c</code> file so that they can be <code>called</code> from V without problems.</p> <p>Replacing the <code>.</code> with <code>_</code>.</p> <p>And each function to be implemented or masked is described in a separate <code>.c.v</code> file, so that it can be called independently from V in order to use as little memory as possible if desired by the user.</p> <p>In this case we must replace <code>Serial1</code> by just <code>Serial</code> in all functions.</p> <p>We delete the unsupported modules and that's it</p> <p>Now let's compile the examples to corroborate the operation.</p> <p>We rename the examples folders and the <code>.v</code> files.</p> <p>it is advisable to open a different vscode session with only the example project file.</p> <p>we must modify the <code>settings.json</code> file in the <code>.vscode</code> directory with the name of the new device.</p> <p>In the case of the flicker example, the transcompilation generated the <code>.ino</code> file and the output binary file in the <code>build</code> folder.</p> <p>now we test it in the Wokwi simulator we can copy the generated code to the simulator</p> <p>As we can see the example of the blinking works</p>"},{"location":"repoFer/Aixt%27s%20V%20language/","title":"Aixt's V language","text":"<p>Aixt V language is based on The V programming language.</p> <p>The V grammar was taken from these sources (ordered by importance): - Abstract Syntax Tree V's documentation: https://modules.vlang.io/v.ast.html - V grammar definition in Antlr-v4:     https://github.com/antlr/grammars-v4/blob/master/v/V.g4 - V grammar definition in lark:         (https://github.com/Itay2805/Vork/blob/master/v.lark</p>"},{"location":"repoFer/Aixt%27s%20V%20language/#diferences-between-aixts-v-and-standard-v","title":"Diferences between Aixt's V and standard V","text":"<ul> <li>As V, Aixt support function attributes like <code>[inline]</code>, but these attributes include others like <code>[task]</code>  which gives support to multitasking in the transpiling to NXC language and <code>[as_macro]</code> for implementing them as C macro (low-memory devices).</li> <li><code>mutex</code>  variables for giving support to multitasking in NXC transcompiling</li> </ul> <p>The main differences between Aixt and Vare show as follows:</p> feature V Aixt's V strings dynamic-sized fixed-sized and dynamic-sized if supported arrays dynamic-sized fixed-sized and dynamic-sized if supported default integers size 32 bits depends on the device structs allow functions (object-oriented) do not allow functions (only structured programming) functions multiple return values only one return value text macros not allowed allowed by using '@[as_macro]' attribute, for functions and constants <code>C</code> variables access not allowed allowed by using 'C.var_name' syntax global variables disabled by default enabled by default"},{"location":"repoFer/Aixt%27s%20V%20language/#vs-supported-keywords","title":"V's supported keywords","text":"<p>The V's supported keywords are listed in bold text as follows. - as - asm - assert - atomic - break - const - defer - else - enum - false - fn - for - go - goto - if - import - in - interface - is - isreftype - lock - match - module - mut - none - or - pub - return - rlock - select - shared - sizeof - spawn - static - struct - true - type - typeof - union - unsafe - volatile - __global - __offsetof</p>"},{"location":"repoFer/Aixt%27s%20V%20language/#aixts-v-language-features","title":"Aixt's V language features","text":"<ul> <li>All variables are local by default</li> <li><code>__global</code>  keyword in case of needing global variables</li> <li>Integer literals in binary, octal, hexadecimal and decimal notation</li> <li>Floating point, <code>rune</code>, <code>string</code>  and boolean literals</li> <li>Numeric literals can include <code>_</code>  for better readability</li> <li>Declaration of signed and unsigned 8, 16, 32 and 64 bit integer variables (also <code>isize</code> and <code>usize</code> )</li> <li>Declaration floating point variables of 32 and 64 bits including scientific notation</li> <li>Multiple declaration and assignment in a single line</li> <li>Declaration by default type inference for scalar and array variables</li> <li>Variable casting in case of need to specify the variable type of number of bits</li> <li>Function attributes using the syntax: </li> </ul> <pre><code>@[attribute] \nfn &lt;name&gt;(&lt;params&gt;) {\n    &lt;statements&gt;\n}```\n\n- Loops with `for` through arrays and integer ranges:\n\n``` v\narr := [3,5,7,9]\nfor a in arr {\n    a = 0\n}\n</code></pre> <pre><code>for i in 1..11 {\n    x += i\n}\n</code></pre>"},{"location":"repoFer/Devices%20and%20Boards/","title":"Supported devices and boards","text":"<p>All the supported devices implement these modules: - <code>time</code>: Delay functions - <code>pin</code>: GPIO - <code>adc</code>: ADC inputs - <code>pwm</code>: PWM outputs - <code>uart</code>: serial port</p> <p>Some other devices like PIC16F and AT support pin-port management: - <code>port</code>: GPIO as multi-bit port</p>"},{"location":"repoFer/Devices%20and%20Boards/#emulator-for-linux-android-termux-and-windows","title":"Emulator for Linux, Android (Termux) and Windows","text":"<ul> <li>x64-based or AArch64-based device: x64 or AArch64 </li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#lego-mindstorms-nxt","title":"LEGO Mindstorms NXT","text":"<ul> <li>NXT Intelligent Brick: AT91SAM7S256 (ARM7TDMI) \"nxc backend\" </li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#microchip","title":"Microchip","text":"<p>For XC8 compiler: - 8-bit 16F family     - PIC16F8x family   (only <code>time</code>, <code>pin</code>, <code>port</code>)     - PIC16F628A    (WIP...)     - PIC16F676     (only <code>time</code>, <code>pin</code>, <code>adc</code>, <code>port</code>).     - PIC16F873A       - PIC16F886    - 8-bit 18F family     - PIC18F452        - PIC18F2550    - Explorer 16: PIC18F4550 (WIP...)</p> <p>For XC16 compiler: - Explorer 16: PIC24FJ128GA010  - Explorer 16: dsPIC33FJ256GP710A (WIP...)</p>"},{"location":"repoFer/Devices%20and%20Boards/#atmel-microchip","title":"Atmel (Microchip)","text":"<ul> <li>Digispark Kickstarter: ATtiny85 \"arduino backend\" (WIP...) </li> <li>MH-Tiny: ATtiny88 \"arduino backend\" </li> <li>Arduino Uno: ATmega328p \"arduino backend\"   </li> <li>Arduino Nano: ATmega328p \"arduino backend\"  </li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#seeed-studio","title":"Seeed Studio","text":"<ul> <li>Seeed Studio XIAO SAMD21: ATSAMD21G18 (Cortex-M0+) \"arduino backend\" </li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#cypress","title":"Cypress","text":"<p>For PSoC Creator: - PSoC 3     - CY8CKIT-001 + (009): CY8C3866AXI-040 (8051) (WIP...) - PSoC 4   - CY8CKIT-049-42xx: CY8C4245AXI-483 (Cortex-M0) (WIP...)   - CY8CKIT-145-40xx: CY8C4045AZI-S413 (Cortex-M0) (WIP...) - PSoC 5LP     - CY8CKIT-059: CY8C5888LTI-LP097 (Cortex-M3) (WIP...)</p>"},{"location":"repoFer/Devices%20and%20Boards/#logicgreen","title":"LogicGreen","text":"<ul> <li>LQFP32 MiniEVB: lgt8f328p \"arduino backend\"</li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#espressif","title":"Espressif","text":"<ul> <li>ESP8266<ul> <li>NodeMCU V3 Lua: ESP8266 (LX106) \"arduino backend\" </li> </ul> </li> <li>ESP32<ul> <li>ESP32 DEVKITV1: ESP32 (LX6) \"arduino backend\" (WIP...)</li> <li>D1 R32: ESP32 (LX6) \"arduino backend\" (WIP...)**</li> <li>CORE-ESP32: ESP32-C3 (RV32) \"arduino backend\" (WIP...)</li> <li>ESP32-C3FH4 Core Board (WeAct Studio): ESP32-C3 (RV32) \"arduino backend\" </li> <li>LILYGO T-Watch 2020 V1: ESP32 (LX6) \"arduino backend\" (WIP...) </li> </ul> </li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#st","title":"ST","text":"<ul> <li>Blue Pill: STM32F103C6 (Cortex-M3) \"arduino backend\" </li> <li>STM32G431CBU6 Core Board: STM32G431CBU6 (Cortex-M4F) \"arduino backend\" (WIP...)</li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#luatos","title":"LuatOS","text":"<ul> <li>CORE-Air32F103CBT6: air32f103 (Cortex-M3) \"arduino backend\" </li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#artery","title":"Artery","text":"<ul> <li>Black Pill: AT32F403ACGU7 (Cortex-M4) \"arduino backend\" (WIP...)</li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#raspberry-pi","title":"Raspberry Pi","text":"<ul> <li>Raspberry Pi Pico: RP2040 (Dual Cortex-M0+) \"arduino backend\" </li> <li>Raspberry Pi Pico W: RP2040 (Dual Cortex-M0+) \"arduino backend\" </li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#wch","title":"WCH","text":"<ul> <li>CH552 Core Board: CH552 (E8051) (WIP...)</li> <li>CH552 Core Board (WeAct Studio): CH552 (E8051) (WIP...)</li> <li>CH573F Core Board: CH573F (RV32) (WIP...)</li> <li>CH582F Core Board: CH582F (RV32) (WIP...)</li> <li>CH32V103R8T6-EVT-R1 Evaluation Board: CH32V103R8T6 (RV32) (WIP...)</li> <li>CH32V003 Development Board: CH32V003F4U6 (RV32) (WIP...)</li> <li>CH32V203 Development Board: CH32V203C8T6 (RV32) (WIP...) </li> <li>CH32V305 Development Board: CH32V305RBT6 (RV32) (WIP...) </li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#winnermicro","title":"WinnerMicro","text":"<ul> <li>HLK-W801-KIT-V1.1: W801-C400 (XT804) \"arduino backend\" (WIP...)</li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#sipeed","title":"Sipeed","text":"<ul> <li>Sipeed M0sense: BL702 (RV32) \"arduino backend\" (WIP...)</li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#ai-thinker","title":"Ai-Thinker","text":"<ul> <li>Ai-WB2-32S-Kit: BL602 \"arduino backend\" (only <code>time</code>, <code>pin</code>, <code>pwm</code>, <code>uart</code>)</li> </ul>"},{"location":"repoFer/Devices%20and%20Boards/#devices-updated-api-v012","title":"Devices updated API v0.1.2","text":"<ul> <li>Software Emulator for Linux, Android (Termux) and Windows     (GCC-TCC)</li> <li>PIC16F8x family: PIC16F83, PIC16F83A, PIC16F84, PIC16F84A     (XC8)</li> <li>Arduino Uno         (arduino-cli)</li> <li>Arduino Nano        (arduino-cli)</li> <li>ESP32-DevKitC       (arduino-cli)</li> <li>Raspberry Pi Pico   (arduino-cli)</li> </ul>"},{"location":"repoFer/General%20folder%20tree/","title":"Project's folder tree","text":"<p>Aixt project has the follow general folder tree:</p> <pre><code>aixt/    \n    \u251c\u2500\u2500 src\n    \u2502   \u251c\u2500\u2500 aixt_build\n    \u2502   :   :\n    \u2502   \u2502   \u2514\u2500\u2500 builder.v\n    \u2502   \u251c\u2500\u2500 aixt_setup\n    \u2502   :   :\n    \u2502   \u2502   \u2514\u2500\u2500 setup.v\n    \u2502   \u251c\u2500\u2500 aixt_cgen\n    \u2502   \u2502   \u251c\u2500\u2500 assign.v\n    \u2502   \u2502   \u251c\u2500\u2500 call.v\n    \u2502   :   :\n    \u2502   \u2502   \u2514\u2500\u2500 utils.v\n    \u2502   \u2514\u2500\u2500 aixt.v\n    \u251c\u2500\u2500 assets\n    \u2502   \u251c\u2500\u2500 Aixtu-ru.jpeg\n    \u2502   \u251c\u2500\u2500 Aixtu-ru-wide.png\n    :   :\n    \u2502   \u2514\u2500\u2500 text-logo.svg\n    \u251c\u2500\u2500 CONTRIBUTING.md\n    \u251c\u2500\u2500 docs\n    \u2502   \u251c\u2500\u2500 Aixt language.md\n    \u2502   \u251c\u2500\u2500 API folder tree.md\n    :   :\n    \u2502   \u251c\u2500\u2500 Setup file.md\n    \u2502   \u251c\u2500\u2500 Atmel\n    \u2502   \u251c\u2500\u2500 Cypress\n    :   :\n    \u2502   \u2514\u2500\u2500 WCH\n    \u251c\u2500\u2500 LICENSE\n    \u251c\u2500\u2500 ports\n    \u2502   \u251c\u2500\u2500 Atmel\n    \u2502   \u251c\u2500\u2500 Cypress\n    :   :\n    \u2502   \u2514\u2500\u2500 WCH\n    \u251c\u2500\u2500 prerequisites.md\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 TODO.md\n    \u2514\u2500\u2500 v.mod\n</code></pre> <ul> <li>The source code is located in the <code>src</code> folder.</li> <li>The <code>assets/</code> folder contains the resource files such images.</li> <li>The <code>ports/</code> folder contains the implementation code for each device or board (mainly Aixt's V source code)</li> <li>The <code>docs/</code> folder contains the documentation for each device or board</li> </ul> <p>For each device or board implementation, two folders with the same name must exist inside <code>ports</code> and <code>docs</code> folders`, for the implementation itself and the correspondent documentation:</p> <pre><code>aixt/    \n    :\n    \u251c\u2500\u2500 docs\n    :   :\n    \u2502   \u251c\u2500\u2500 Emulator\n    :   :\n    :\n    \u251c\u2500\u2500 ports\n    :   :\n    \u2502   \u251c\u2500\u2500 Emulator\n    :   :\n    :\n</code></pre>"},{"location":"repoFer/General%20folder%20tree/#ports-folder","title":"<code>ports</code> folder","text":"<p>This contains the implementation in C language of the Aixt API, projects and Aixt examples, of each device or board. The recommended folder tree for each port is:</p> <pre><code>device_or_board_name/    \n    \u251c\u2500\u2500 api\n    \u2502   \u251c\u2500\u2500 pin/\n    :   :   \n    \u2502   \u2514\u2500\u2500 builtin.c\n    \u251c\u2500\u2500 examples\n    \u2502   \u251c\u2500\u2500 example_1.v\n    \u2502   \u251c\u2500\u2500 example_2.v\n    :   :\n    \u2502   \u2514\u2500\u2500 example_n.v\n    \u2514\u2500\u2500 projects\n        \u251c\u2500\u2500 project_1\n        \u251c\u2500\u2500 project_2\n        :\n        \u2514\u2500\u2500 project_n\n</code></pre> <p>The <code>projects</code> folder could contain the project folders ad files for the spefific compiler and the <code>examples</code> folder should only contain Aixt (V) source files.</p>"},{"location":"repoFer/General%20folder%20tree/#docs-folder","title":"<code>docs</code> folder","text":"<p>This contains the documentation for each device or board implementation. This should be contain at least a quick reference guide <code>quickref.md</code>:</p> <pre><code>device_or_board_name/    \n    \u251c\u2500\u2500 quickref.md\n    :\n    :\n    \u2514\u2500\u2500 pin_descrition.md\n</code></pre> <p>The <code>projects</code> folder could contain the project folders and files for the specific compiler and the <code>examples</code> folder should only contain Aixt (V) source files.</p>"},{"location":"repoFer/How%20to%20use/","title":"Using Aixt project","text":""},{"location":"repoFer/How%20to%20use/#run-aixt","title":"Run Aixt","text":"<p>In a terminal inside the Aixt folder compile and execute <code>aixt.v</code> file:</p> <pre><code>v run aixt.v &lt;command&gt; &lt;device_or_board&gt; &lt;source_file&gt;\n</code></pre> <p>Examples:</p> <pre><code>v run aixt.v -t Emulator ports/PC/projects/blinking/blinking.v\n</code></pre> <pre><code>v run aixt.v -c Exp16-PIC24 common_test/17_for_in_range.v\n</code></pre>"},{"location":"repoFer/How%20to%20use/#compile-aixt","title":"Compile Aixt","text":"<p>For improving the transcompilation from Aixt to C ou can compile first <code>aixt.v</code>: </p> <pre><code>v aixt.v\n</code></pre> <p>and the execute:</p> <pre><code>./aixt &lt;command&gt; &lt;device_or_board&gt; &lt;source_file&gt;\n</code></pre> <p>Examples:</p> <pre><code>./aixt -t Emulator common_test/02_casting.v\n</code></pre> <pre><code>./aixt -b NXT ports/NXT/projects/1_motor.write.v\n</code></pre>"},{"location":"repoFer/How%20to%20use/#aixt-commands","title":"Aixt commands","text":"<p>Aixt supports the following commands:</p> Command working transpile, -t Transpile to C an Aixt program. compile, -c Compile the previously generated C file. run, -r Run the previously generated executable file. build, -b Build (transpile, compile and run) an Aixt program. clean, -cl Clean all the generated file (C and executables). help, --help, -h Call this help' version Print the Aixt version number"},{"location":"repoFer/Libraries%20folder%20tree/","title":"Aixt Libraries folder tree","text":"<p>Libraries in Aixt are located in the <code>lib</code> folder following this folder tree:</p> <pre><code>aixt/lib/\n    \u251c\u2500\u2500 arduino/\n    \u2502   \u251c\u2500\u2500 arduino_lib/\n    \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 arduino_lib.c\n    \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 arduino_lib.c.v\n    \u2502   \u2502\u00a0\u00a0 \u2514\u2500\u2500 function_1/\n    \u2502   \u2502\u00a0\u00a0     \u251c\u2500\u2500 function_1.c\n    \u2502   \u2502\u00a0\u00a0     \u2514\u2500\u2500 function_1.c.v\n    :   :\n    :\n    \u251c\u2500\u2500 c/\n    \u2502   \u251c\u2500\u2500 c_lib/\n    \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 c_lib.c\n    \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 c_lib.c.v\n    \u2502   \u2502\u00a0\u00a0 \u2514\u2500\u2500 function_1/\n    \u2502   \u2502\u00a0\u00a0     \u251c\u2500\u2500 function_1.c\n    \u2502   \u2502\u00a0\u00a0     \u2514\u2500\u2500 function_1.c.v\n    :   :\n    :\n    \u251c\u2500\u2500 nxc/\n    \u2502   \u251c\u2500\u2500 nxc_lib/\n    \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 nxc_lib.c\n    \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 nxc_lib.c.v\n    \u2502   \u2502\u00a0\u00a0 \u2514\u2500\u2500 function_1/\n    \u2502   \u2502\u00a0\u00a0     \u251c\u2500\u2500 function_1.c\n    \u2502   \u2502\u00a0\u00a0     \u2514\u2500\u2500 function_1.c.v\n    :   :\n    :\n    \u251c\u2500\u2500 generic_lib/\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 generic_lib.c\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 generic_lib.c.v\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 function_1/\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 function_1.c\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 function_1.c.v\n    :\n</code></pre>"},{"location":"repoFer/Libraries/","title":"Aixt Libraries","text":""},{"location":"repoFer/Setup%20files/","title":"Setup files","text":"<p>The Aixt project uses setup files for each supported microcontroller and compiler. These files configure the specific configuration parameters of the board or device such as: clock frequency, default hardware modules, header files etc., as well as other transpiler parameters such as variable type correspondence. The setup files are located in <code>setup</code> folder.</p> <p>The setup files use the <code>.json</code> format due to its ubiquitous nature. The following sample code shows the content of <code>setup/PIC16F8x.json</code>:</p> <pre><code>{\n    \"port\":      \"PIC16F8x\",\n    \"board\":     \"---\",\n    \"backend\":   \"c\",\n\n    \"cc_linux\":         \"\",             \n    \"cc_windows\":       \"\",\n    \"cc_make_flags\":    \"PART=@{device}\",\n\n    \"flasher_linux\":    \"arduino-cli\",\n    \"flasher_windows\":  \"arduino-cli.exe\",\n    \"flasher_flags\":    \"upload @{file_dir_name} -p @{port} -b esp32:esp32:esp32\",\n\n    \"api_paths\": [\n        \"Microchip/PIC16F8x\",\n        \"Microchip/xc8-generic\",\n        \"Microchip/PIC12F-16F-generic\"\n    ],\n    \"v_defines\": [\n    ],\n\n    \"default_cpu_freq\": 4000000,\n    \"default_string_len\": 20,\n\n    \"compiler_setup_path\": \"setup/xc8.json\"\n}\n</code></pre> <p>Each device's setup file <code>port_name.json</code> includes at the same time the correspondent compiler's setup file <code>compiler.json</code> in the parameter: <code>\"compiler_setup_path\":</code>. In this case <code>setup/xc8.json</code>, which has the followng content:</p> <pre><code>{\n    \"main_ret_type\": \"void\",\n    \"main_params\":   \"void\",\n    \"compiler_types\": {\n        \"void\":     \"void\",\n        \"bool\":     \"bool\",\n        \"i8\":       \"int8_t\",\n        \"i16\":      \"int16_t\",\n        \"int\":      \"int32_t\",\n        \"i64\":      \"NOT SUPPORTED\",\n        \"isize\":    \"int8_t\",\n        \"int_literal\": \"int32_t\",\n        \"u8\":       \"uint8_t\",\n        \"u16\":      \"uint16_t\",\n        \"u32\":      \"uint32_t\",\n        \"u64\":      \"NOT SUPPORTED\",\n        \"usize\":    \"uint8_t\",\n        \"f32\":      \"float\",\n        \"f64\":      \"NOT SUPPORTED\",\n        \"float_literal\": \"float\",\n        \"rune\":     \"char\"\n    }\n}\n</code></pre> <p>The Aixt transpiler reads the <code>port_name.json</code> and  <code>compiler.json</code> and does the translation based on the parameters written on it, as well as adding the specific parameters of the microcontroller or board in the output <code>C</code> file. </p>"},{"location":"repoFer/Setup%20files/#backend","title":"Backend","text":"<p>Aixt can generated code for 3 different backends:</p> Backend name Target c for the native C compiler of the device arduino for the ports that use Arduino API nxc for LEGO Mindstorms NXT robots on NXC language"},{"location":"repoFer/Testing/","title":"Aixt Project Test Plan","text":"<ul> <li> <p>To help uniformity, quality, and reliability in the development of the Aixt project itself with the support of microcontroller-based systems, the \"test\" folder is added.</p> </li> <li> <p>This folder contains two types of tests: smoke tests and functional tests. Below is an explanation of what each folder contains and how to use the test suites within them.</p> </li> </ul>"},{"location":"repoFer/Testing/#smoke-test-folder","title":"Smoke Test Folder","text":"<p>The smoke test folder includes tests that provide a quick check to ensure the basic functionality of the code is working correctly. These tests are not exhaustive but are designed to catch critical issues early.</p>"},{"location":"repoFer/Testing/#purpose","title":"Purpose:","text":"<p>To verify the essential features and basic functionalities of the application.</p>"},{"location":"repoFer/Testing/#how-to-use","title":"How to Use:","text":"<p>Simply follow the test suite within this folder to ensure that the primary functions of the code are operating as expected. This is usually done after a new build or an update to make sure that the main features have not been broken.</p>"},{"location":"repoFer/Testing/#functional-test-folder","title":"Functional Test Folder","text":"<p>The functional test folder contains more comprehensive tests that validate the complete functionality of the code against the requirements. These tests are more detailed and ensure that the code behaves as expected under various conditions.</p>"},{"location":"repoFer/Testing/#purpose_1","title":"Purpose:","text":"<p>To validate that the code works according to the specified requirements and performs all intended functions correctly.</p>"},{"location":"repoFer/Testing/#how-to-use_1","title":"How to Use:","text":"<p>Follow the test suite within this folder to conduct thorough testing of the code's features. This includes testing individual functions, integrations, and workflows to ensure everything operates smoothly as expected.</p> <p>Note: All Smoke test cases must pass before running the Functional test cases.</p>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/","title":"Fast guide AI-WB2-32S-KIT","text":"<p>This Aixt implementation that supports the card  AI-WB2-32S-KIT</p>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#id-card-ai-wb2-32s-kit","title":"ID card AI-WB2-32S-KIT","text":""},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#view","title":"View","text":"<ul> <li>Ai-WB2-32S-Kit, a total of 38 interfaces are connected, for example, the pin function definition table is the interface definition.</li> </ul> <p> Image taken from the device datasheet</p>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#datasheet","title":"Datasheet","text":"<p>AI-WB2-32S-KIT</p>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#port-identification","title":"Port Identification","text":"<p>Below are the ports used and their proper designations for programming:</p> No. Name Function 1 3V3 3.3V power supply; The output current of the external power supply is recommended to be above 500mA 2 EN By default, it is enabled as a chip, and the high level is effective 3 NC Empty feet 4 IO11 GPIO11/SPI_SCLK/IIC_SDA/ADC_CH10/JTAG_TDI/TDO 5 NC Empty feet 6 Empty feet Empty feet 7 IO14 GPIO14/SPI_SS/IIC_SCL/PWM_CH4/ADC_CH2/JTAG_TCK/TMS 8 IO17 GPIO17/SPI_MOSI/MISO/IIC_SDA/PWM_CH2/JTAG_TCK/TMS 9 IO3 GPIO3/SPI_SCLK/IIC_SDA/PWM_CH3/JTAG_TDO/TDI 10 IO20/NC The default NC is unavailable 11 IO22/NC The default NC is unavailable 12 IO0/NC The default NC is unavailable 13 IO21/NC The default NC is unavailable 14 GND Ground 15 NC Empty feet 16 NC Empty feet 17 NC Empty feet 18 NC Empty feet 19 5V 5V power supply; External power supply output current is recommended to be above 500mA 20 NC Empty feet 21 NC Empty feet 22 NC Empty feet 23 NC Empty feet 24 NC Empty feet 25 IO8/NC The default NC is unavailable. 26 NC Empty feet 27 IO4 GPIO4/SPI_MOSI/MISO/IIC_SCL/PWM_CH4/ADC_CH1 28 IO2/NC The default NC is unavailable 29 NC Empty feet 30 IO1/NC The default NC is unavailable 31 IO5 GPIO5/SPI_MOSI/MISO/IIC_SDA/PWM_CH0/ADC_CH4/JTAG_T MS/TCK 32 NC Empty feet 33 NC Empty feet 34 RX RXD/GPIO7/SPI_SCLK/IIC_SDA/PWM_CH2/JTAG_TDO/TDI 35 TX TXD/GPIO16/SPI_MOSI/MISO/IIC_SCL/PWM_CH1/JTAG_TMS/T CK 36 IO12 GPIO12/SPI_MOSI/MISO/IIC_SCL/PWM_CH2/ADC_CH0/JTAG_T MS/TCK 37 NC Empty feet 38 GND Ground"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#programming-in-v-language","title":"Programming in v language","text":"<p>For each of these modules, you will have a file in .c.v format with the same name of the module and in this you will have the text module followed by the name of the module, example: * module pin * module pwm * module uart</p>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#output-port-configuration","title":"Output port configuration","text":"<p>To activate the port to use</p> <pre><code>pin.setup(pin_name, pin.output)\n</code></pre> <ul> <li>Example: If you want to activate the port 17;  <code>pin.setup(pin.io17, pin.output)</code>. To activate the port to use</li> </ul> <pre><code>pin.high(pin_name)\n</code></pre> <ul> <li>Example: If you want to activate the port 17;  <code>pin.high(pin.io17)</code>.</li> </ul> <p>To disable the port being used</p> <pre><code>pin.low(pin_name)\n</code></pre> <ul> <li>Example: If you want to disable the port 17;  <code>pin.low(pin.io17)</code>.</li> </ul> <p>To disable or enable the port to be used</p> <pre><code>pin.write(pin_name, VALUE)\n</code></pre> <ul> <li>Example: If you want to disable port 17 <code>pin.write(pin.io17, 1)</code>, and if you want to activate  <code>pin.write(pin.io17, 0)</code>.</li> </ul>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#input-port-detection","title":"Input port detection","text":"<p>If you need to know what state an entry port is in:</p> <pre><code>x = pin.read(pin_name)\n</code></pre> <ul> <li>Example: If you want to detect the VALUE of port 3; <code>x = pin.read(pin.io3)</code>, and <code>x</code> will take the VALUE of 0 or 1, depending on which port is active or disabled.</li> </ul>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#pulse-width-modulation-pwm-outputs","title":"Pulse Width Modulation (PWM outputs)","text":"<p>To configure some PWM</p> <pre><code>pin.setup(pin_name, pin.output)\n</code></pre> <ul> <li>Example: in pwm you set the PWM to use <code>pin.setup(pin.io17, pin.output)</code></li> </ul> <p>To configure the duty cycle of a modulator</p> <p>Everything is implemented within a for, with a counter up to the desired cycles</p> <pre><code>pwm.write(pin_name, pin.output)\n</code></pre> <ul> <li>Example: in pwm you set the PWM to use </li> </ul> <pre><code>for {\n    pwm.write(pin.io17, val)\n    sleep_ms(250)\n    val += 10\n    if val == 250 {\n          val = 0  \n    }\n}\n</code></pre>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#serial-communication-uart","title":"Serial communication (UART)","text":"<p>The UART used to be the standard stream output, so the functions <code>print()</code>, <code>println()</code> and <code>input()</code> work directly on the default UART. The default UART could change depending on the board or microcontroller, please refer to the specific documentation. The syntax for most of UART functions is: <code>uart_function_name_x()</code>, being <code>x</code> the identifying number in case of multiple UARTs. You can omit the <code>x</code> for referring to the first or default UART, or in the case of having only one.  </p>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#uart-setup","title":"UART setup","text":"<p>For the UART module it is implemented as follows:</p> <pre><code>uart.setup(BAUD_RATE)\n</code></pre> <ul> <li><code>BAUD_RATE</code> configure the communication speed</li> <li>Example: in uart to use <code>uart.setup(115200)</code></li> </ul>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#serial-transmitting","title":"Serial transmitting","text":"<pre><code>uart.print(message)      // print a string to the default UART\n</code></pre> <ul> <li>Example: This is used as <code>uart.print(Uart for AIXT)</code></li> </ul> <pre><code>uart.println(message)    // print a string plus a line-new character to the default UART\n</code></pre> <ul> <li>Example: This is used as <code>uart.println(Command received)</code></li> </ul> <pre><code>uart.ready // get everything ready for to UART\n</code></pre> <ul> <li>Example: This is used as <code>uart.ready()</code></li> </ul> <pre><code>uart.read // receives binary data (in Bytes) to UART\n</code></pre> <ul> <li>Example: This is used as <code>uart.read()</code></li> </ul> <pre><code>uart.write(message)    // send binary data (in Bytes) to second UART\n</code></pre> <ul> <li>Example: This is used as <code>uart.write()</code></li> </ul>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#retardos","title":"Retardos","text":"<ul> <li> <p>Use of times</p> <ul> <li>In each expression, the time VALUE is put inside the parentheses.</li> </ul> </li> </ul> <pre><code>time.sleep(s) //Seconds\n</code></pre> <ul> <li>Example: This is used as <code>time.sleep(2)</code></li> </ul> <pre><code>time.sleep_ms(ms) //Milliseconds\n</code></pre> <ul> <li>Example: This is used as <code>time.sleep_ms(500)</code></li> </ul> <pre><code>time.sleep_us(us) //Microseconds\n</code></pre> <p>Example: This is used as <code>time.sleep_us(5000)</code></p>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#implementation-of-the-aixt-project","title":"Implementation of the AIXT project","text":"<p>For the development of the program, some examples of the codes in v languages \u200b\u200bare shown, which will be transpiled * Example flashing LED</p> <pre><code>import pin\nimport time {sleep_ms}\n\npin.setup(pin.io14, pin.output)\n\nfor {   //infinite loop\n    pin.high(pin.io14)\n    sleep_ms(500)\n    pin.low(pin.io14)\n    sleep_ms(500)\n}\n</code></pre> <ul> <li>Example PWM</li> </ul> <pre><code>import time {sleep_ms}\nimport pin\nimport pwm\n\n__global val = 0\n\npin.setup(pin.io17, pin.output)\n\nfor {\n    pwm.write(pin.io17, val)\n    sleep_ms(250)\n    val=val+10\n    if val==250{\n        val=0  \n    }\n} \n</code></pre> <ul> <li>Example UART</li> </ul> <pre><code>import time {sleep_ms}\nimport pin\nimport uart\n\n\n  uart.setup(115200)\n  pin.setup(pin.io4,output)\n  pin.setup(pin.io5,output)\n  pin.setup(pin.io12,output)\n\nfor {\n  uart.println(\"\\r\\n Este programa realiza unas funciones establecidas:\")\n  uart.println(\"\\r\\n Oprimiendo la letra A, activa la salida  del pin GPIO4.\")\n  uart.println(\"\\r\\n Oprimiendo la letra B, activa la salida  del pin GPIO5.\")\n  uart.println(\"\\r\\n El piloto (led) Rojo indica que esta esperando instrucciones.\")\n  uart.println(\"\\r\\n Esperando instrucciones: \\r\\n\")\n\n  pin.high(pin.io12)\n  sleep_ms(500)\n\n  pin.low(pin.io12)\n  sleep_ms(500)\n  x:=0\n  x=uart.available()\n  if  x&gt; 0 {\n  command := ` `\n    command = uart.read_0()\n\n    if command==`A` {\n        uart.println(\"\\r\\n Comando A recibido. \\r\\n\")\n        uart.println(\"\\r\\n Realizando acci\u00f3n A. \\r\\n\")\n        pin.high(pin.io4)\n        sleep_ms(5000)\n\n        pin.low(pin.io4)\n        sleep_ms(1000)\n        uart.println(\"\\r\\n Proceso A finalizado. \\r\\n\")\n    }\n\n      if command==`B` {\n        uart.println(\"\\r\\n Comando B recibido. \\r\\n\")\n        uart.println(\"\\r\\n Realizando acci\u00f3n B. \\r\\n\")\n        pin.high(pin.io5)\n        sleep_ms(5000)\n\n        pin.low(pin.io5)\n        sleep_ms(1000)\n        uart.println(\"\\r\\n Proceso B finalizado. \\r\\n\")\n      }\n\n      else {\n        pin.high(pin.io12)\n        sleep_ms(1000)\n\n        pin.low(pin.io12)\n        sleep_ms(1000)\n\n    }\n  }\n}\n</code></pre>"},{"location":"repoFer/Ai-Thinker/Ai-WB2-32S-Kit/quickref/#informative-video","title":"Informative video","text":"<p>Informative video on the development of the AIXT project, with the device https://youtu.be/BRSWZXQ2mLY</p>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/","title":"Quick reference for the Arduino Uno board","text":""},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#configuration-of-pins-and-their-respective-functions","title":"CONFIGURATION OF PINS AND THEIR RESPECTIVE FUNCTIONS","text":""},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#delay","title":"Delay","text":"<p>Use the <code>time</code> module:</p> <pre><code>import time\n\ntime.sleep(2)            // sleep for 2 seconds\ntime.sleep_ms(50)        // sleep for 50 milliseconds\ntime.sleep_us(100)       // sleep for 100 microseconds\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#functions","title":"Functions","text":"name description <code>time.sleep(time)</code> Delay in seconds <code>time.sleep_us(time)</code> Delay in microseconds <code>time.sleep_ms(time)</code> Delay in milliseconds"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#internal-leds","title":"Internal LEDs","text":"<p>The onboard LED is named <code>led_0</code> </p> <pre><code>import pin\n\npin.setup(led_0, pin.output)\npin.high(led_0)\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#pins","title":"Pins","text":"<p>Use the <code>pin</code> module:</p> <pre><code>import pin\n\npin.setup(pin.d0, pin.input)\npin.high(pin.d13)\npin.low(pin.d3)\npin.write(pin.d8, pin.read(pin.d0)) // pin echo\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#functions_1","title":"Functions","text":"name description <code>pin.setup(pin, mode)</code> Configure <code>pin</code> as <code>mode</code> <code>pin.high(pin)</code> Turn On <code>pin</code> <code>pin.low(pin)</code> Turn Off <code>pin</code> <code>pin.write(pin, value)</code> Write <code>value</code> in <code>pin</code> <code>pin.read(pin)</code> Return the state of <code>pin</code>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#digital-pin-names","title":"Digital pin names","text":"<p>The digital pin names are named from <code>d0</code> to <code>d69</code>.</p>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#pin-ports","title":"Pin ports","text":"<p>Use the <code>port</code> module:</p> <pre><code>import port\n\nport.setup(port.b, port.all_outputs)\nport.setup(port.c, port.all_inputs)  // port A bit 7 and 6 as outputs, the rest as inputs\n\nval := port.read(port.c)\nport.write(port.b, val) // port echo\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#functions_2","title":"Functions","text":"name description <code>port.setup(port, mode)</code> Configure <code>port</code> as <code>mode</code> <code>port.read(port)</code> Return the value of <code>port</code> <code>port.write(port, value)</code> Write <code>value</code> to <code>port</code>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#digital-port-names","title":"Digital port names","text":"Port Aixt name B <code>b</code> C <code>c</code> D <code>d</code> E <code>e</code> F <code>f</code> G <code>g</code> H <code>h</code> J <code>j</code> K <code>k</code>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#pwm-pulse-width-modulation","title":"PWM (Pulse Width Modulation)","text":"<p>Use the <code>pwm</code> module:</p> <pre><code>import pwm\n\npwm.write(pwm.ch0, 40)       // set the duty cycle for PWM channel 0\npwm.write(pwm.ch1, 60)       // set the duty cycle for PWM channel 1\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#functions_3","title":"Functions","text":"name description <code>pwm.write(channel, value)</code> Write <code>value</code> in the PWM <code>channel</code>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#pwm-pin-names","title":"PWM pin names","text":"<p>The PWM channels are named from <code>ch0</code> to <code>ch11</code>.</p>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#adc-analog-to-digital-converter","title":"ADC (Analog to Digital Converter)","text":"<p>Use the <code>adc</code> module:</p> <pre><code>import adc\n\nval1 := adc.read(ch0)       // read de ADC channel 0\nval2 := adc.read(ch1)       // read de ADC channel 1\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#functions_4","title":"Functions","text":"name description <code>adc.read(channel)</code> Return the ADC value in <code>channel</code>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#analog-channels","title":"Analog channels","text":"<p>The PWM channels are named from <code>ch0</code> to <code>ch15</code>.</p>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#uart-serial-port","title":"UART (serial port)","text":"<p>Use the <code>uart0</code> , <code>uart1</code> , <code>uart2</code> or <code>uart3</code> module:</p> <pre><code>import uart\n\nuart.print('Hello ')\nuart.println('World...')\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Mega/quickref/#functions_5","title":"Functions","text":"name description <code>uart.setup(baud_rate)</code> Configure the <code>baud_rate</code> of the UART <code>uart.read()</code> Return one character received by UART <code>uart.input(message)</code> Send the <code>message</code> and then return the string received by UART <code>uart.write(character)</code> Send one character by UART <code>uart.print(message)</code> Send the <code>message</code> by UART <code>uart.println(message)</code> Send the <code>message</code> plus a new line by UART <code>uart.any()</code> Return the number uf characters in the UART's buffer <code>uart1.setup(baud_rate)</code> Configure the <code>baud_rate</code> of the UART 1 <code>uart1.ready()</code> <code>uart1.read()</code> Return one character received by UART 1 <code>uart1.print(message)</code> Send the <code>message</code> by UART 1 <code>uart1.println(message)</code> Send the <code>message</code> plus a new line by UART 1 <code>uart1.any()</code> Return the number uf characters in the UART1's buffer <code>uart2.setup(baud_rate)</code> Configure the <code>baud_rate</code> of the UART 2 <code>uart2.ready()</code> <code>uart2.read()</code> Return one character received by UART 2 <code>uart2.print(message)</code> Send the <code>message</code> by UART 2 <code>uart2.println(message)</code> Send the <code>message</code> plus a new line by UART 2 <code>uart2.any()</code> Return the number uf characters in the UART2's buffer <code>uart3.setup(baud_rate)</code> Configure the <code>baud_rate</code> of the UART 3 <code>uart3.ready()</code> <code>uart3.read()</code> Return one character received by UART 3 <code>uart3.print(message)</code> Send the <code>message</code> by UART 3 <code>uart3.println(message)</code> Send the <code>message</code> plus a new line by UART 3 <code>uart3.any()</code> Return the number uf characters in the UART2's buffer"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/","title":"Quick reference for the Arduino Nano board","text":""},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#configuration-of-pins-and-their-respective-functions","title":"CONFIGURATION OF PINS AND THEIR RESPECTIVE FUNCTIONS","text":""},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#delay","title":"Delay","text":"<p>Use the <code>time</code> module:</p> <pre><code>import time\n\ntime.sleep(2)            // sleep for 2 seconds\ntime.sleep_ms(50)        // sleep for 50 milliseconds\ntime.sleep_us(100)       // sleep for 100 microseconds\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#functions","title":"Functions","text":"name description <code>time.sleep(time)</code> Delay in seconds <code>time.sleep_us(time)</code> Delay in microseconds <code>time.sleep_ms(time)</code> Delay in milliseconds"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#internal-leds","title":"Internal LEDs","text":"<p>The onboard LED is named <code>led_0</code> </p> <pre><code>import pin\n\npin.setup(led_0, pin.output)\npin.high(led_0)\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#pins","title":"Pins","text":"<p>Use the <code>pin</code> module:</p> <pre><code>import pin\n\npin.setup(pin.d0, pin.input)\npin.high(pin.d13)\npin.low(pin.d3)\npin.write(pin.d8, pin.read(pin.d0)) // pin echo\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#functions_1","title":"Functions","text":"name description <code>pin.setup(pin, mode)</code> Configure <code>pin</code> as <code>mode</code> <code>pin.high(pin)</code> Turn On <code>pin</code> <code>pin.low(pin)</code> Turn Off <code>pin</code> <code>pin.write(pin, value)</code> Write <code>value</code> in <code>pin</code> <code>pin.read(pin)</code> Return the state of <code>pin</code>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#digital-pin-names","title":"Digital pin names","text":"<p>The digital pin names are named from <code>d0</code> to <code>d21</code>.</p>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#pin-ports","title":"Pin ports","text":"<p>Use the <code>port</code> module:</p> <pre><code>import port\n\nport.setup(port.b, port.all_outputs)\nport.setup(port.c, port.all_inputs)  // port A bit 7 and 6 as outputs, the rest as inputs\n\nval := port.read(port.c)\nport.write(port.b, val) // port echo\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#functions_2","title":"Functions","text":"name description <code>port.setup(port, mode)</code> Configure <code>port</code> as <code>mode</code> <code>port.read(port)</code> Return the value of <code>port</code> <code>port.write(port, value)</code> Write <code>value</code> to <code>port</code>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#digital-port-names","title":"Digital port names","text":"Port Aixt name B <code>b</code> A <code>c</code> B <code>d</code>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#pwm-pulse-width-modulation","title":"PWM (Pulse Width Modulation)","text":"<p>Use the <code>pwm</code> module:</p> <pre><code>import pwm\n\npwm.write(pwm.ch0, 40)       // set the duty cycle for PWM channel 0\npwm.write(pwm.ch1, 60)       // set the duty cycle for PWM channel 1\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#functions_3","title":"Functions","text":"name description <code>pwm.write(channel, value)</code> Write <code>value</code> in the PWM <code>channel</code>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#pwm-pin-names","title":"PWM pin names","text":"<p>The PWM channels are named from <code>ch0</code> to <code>ch5</code>.</p>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#adc-analog-to-digital-converter","title":"ADC (Analog to Digital Converter)","text":"<p>Use the <code>adc</code> module:</p> <pre><code>import adc\n\nval1 := adc.read(ch0)       // read de ADC channel 0\nval2 := adc.read(ch1)       // read de ADC channel 1\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#functions_4","title":"Functions","text":"name description <code>adc.read(channel)</code> Return the ADC value in <code>channel</code>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#analog-channels","title":"Analog channels","text":"<p>The PWM channels are named from <code>ch0</code> to <code>ch7</code>.</p>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#uart-serial-port","title":"UART (serial port)","text":"<p>Use the <code>uart</code> module:</p> <pre><code>import uart\n\nuart.print('Hello ')\nuart.println('World...')\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Nano/quickref/#functions_5","title":"Functions","text":"name description <code>uart.setup(baud_rate)</code> Configure the <code>baud_rate</code> of the UART <code>uart.read()</code> Return one character received by UART <code>uart.input(message)</code> Send the <code>message</code> and then return the string received by UART <code>uart.write(character)</code> Send one character by UART <code>uart.print(message)</code> Send the <code>message</code> by UART <code>uart.println(message)</code> Send the <code>message</code> plus a new line by UART <code>uart.any()</code> Return the number uf characters in the UART's buffer"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/","title":"Quick reference for the Arduino Uno board","text":""},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#configuration-of-pins-and-their-respective-functions","title":"CONFIGURATION OF PINS AND THEIR RESPECTIVE FUNCTIONS","text":""},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#delay","title":"Delay","text":"<p>Use the <code>time</code> module:</p> <pre><code>import time\n\ntime.sleep(2)            // sleep for 2 seconds\ntime.sleep_ms(50)        // sleep for 50 milliseconds\ntime.sleep_us(100)       // sleep for 100 microseconds\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#functions","title":"Functions","text":"name description <code>time.sleep(time)</code> Delay in seconds <code>time.sleep_us(time)</code> Delay in microseconds <code>time.sleep_ms(time)</code> Delay in milliseconds"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#internal-leds","title":"Internal LEDs","text":"<p>The onboard LED is named <code>led_0</code> </p> <pre><code>import pin\n\npin.setup(led_0, pin.output)\npin.high(led_0)\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#pins","title":"Pins","text":"<p>Use the <code>pin</code> module:</p> <pre><code>import pin\n\npin.setup(pin.d0, pin.input)\npin.high(pin.d13)\npin.low(pin.d3)\npin.write(pin.d8, pin.read(pin.d0)) // pin echo\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#functions_1","title":"Functions","text":"name description <code>pin.setup(pin, mode)</code> Configure <code>pin</code> as <code>mode</code> <code>pin.high(pin)</code> Turn On <code>pin</code> <code>pin.low(pin)</code> Turn Off <code>pin</code> <code>pin.write(pin, value)</code> Write <code>value</code> in <code>pin</code> <code>pin.read(pin)</code> Return the state of <code>pin</code>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#digital-pin-names","title":"Digital pin names","text":"<p>The digital pin names are named from <code>d0</code> to <code>d19</code>.</p>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#pin-ports","title":"Pin ports","text":"<p>Use the <code>port</code> module:</p> <pre><code>import port\n\nport.setup(port.b, port.all_outputs)\nport.setup(port.c, port.all_inputs)  // port A bit 7 and 6 as outputs, the rest as inputs\n\nval := port.read(port.c)\nport.write(port.b, val) // port echo\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#functions_2","title":"Functions","text":"name description <code>port.setup(port, mode)</code> Configure <code>port</code> as <code>mode</code> <code>port.read(port)</code> Return the value of <code>port</code> <code>port.write(port, value)</code> Write <code>value</code> to <code>port</code>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#digital-port-names","title":"Digital port names","text":"Port Aixt name B <code>b</code> C <code>c</code> D <code>d</code>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#pwm-pulse-width-modulation","title":"PWM (Pulse Width Modulation)","text":"<p>Use the <code>pwm</code> module:</p> <pre><code>import pwm\n\npwm.write(pwm.ch0, 40)       // set the duty cycle for PWM channel 0\npwm.write(pwm.ch1, 60)       // set the duty cycle for PWM channel 1\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#functions_3","title":"Functions","text":"name description <code>pwm.write(channel, value)</code> Write <code>value</code> in the PWM <code>channel</code>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#pwm-pin-names","title":"PWM pin names","text":"<p>The PWM channels are named from <code>ch0</code> to <code>ch5</code>.</p>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#adc-analog-to-digital-converter","title":"ADC (Analog to Digital Converter)","text":"<p>Use the <code>adc</code> module:</p> <pre><code>import adc\n\nval1 := adc.read(ch0)       // read de ADC channel 0\nval2 := adc.read(ch1)       // read de ADC channel 1\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#functions_4","title":"Functions","text":"name description <code>adc.read(channel)</code> Return the ADC value in <code>channel</code>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#analog-channels","title":"Analog channels","text":"<p>The PWM channels are named from <code>ch0</code> to <code>ch5</code>.</p>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#uart-serial-port","title":"UART (serial port)","text":"<p>Use the <code>uart</code> module:</p> <pre><code>import uart\n\nuart.print('Hello ')\nuart.println('World...')\n</code></pre>"},{"location":"repoFer/Arduino/Arduino-Uno/quickref/#functions_5","title":"Functions","text":"name description <code>uart.setup(baud_rate)</code> Configure the <code>baud_rate</code> of the UART <code>uart.read()</code> Return one character received by UART <code>uart.input(message)</code> Send the <code>message</code> and then return the string received by UART <code>uart.write(character)</code> Send one character by UART <code>uart.print(message)</code> Send the <code>message</code> by UART <code>uart.println(message)</code> Send the <code>message</code> plus a new line by UART <code>uart.any()</code> Return the number uf characters in the UART's buffer"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/","title":"GU\u00cdA R\u00c1PIDA MH-ATTINY88","text":"<p>Implementaci\u00f3n de Aixt para soportar la tarjeta MH-ATtiny88.</p>"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#resumen","title":"RESUMEN","text":"<ul> <li> <p>El microcontrolador ATtiny88 es un microcontrolador AVR de alto rendimiento y tama\u00f1o reducido que utiliza un procesador RISC. Este microcontrolador viene en dos paquetes que se utilizan principalmente para la interfaz y el control entre diferentes sensores y dispositivos.</p> </li> <li> <p>Este microcontrolador est\u00e1 disponible con bajo consumo de energ\u00eda a trav\u00e9s de MSSP y ADC de 10 bits. El c\u00f3digo de instrucci\u00f3n de este microcontrolador puede almacenarse a trav\u00e9s de SRAM - 512 bytes y EEPROM - 64 bytes, fabricado por Micro Ship Tecnologic.</p> </li> <li> <p>Dispositivo dise\u00f1ado para aplicaciones integradas. Est\u00e1 basado en la arquitectura AVR de 8 bits y cuenta con una amplia gama de perif\u00e9ricos integrados, incluidos puertos GPIO, interfaces de comunicaci\u00f3n serial, temporizadores y convertidores anal\u00f3gico-digital. El MH-AT-tiny88 es adecuado para una variedad de aplicaciones, desde sistemas de control b\u00e1sicos hasta dispositivos port\u00e1tiles y sensores IoT debido a su combinaci\u00f3n de tama\u00f1o compacto, bajo consumo de energ\u00eda y funcionalidad vers\u00e1til.</p> </li> </ul>"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#las-funciones","title":"LAS FUNCIONES:","text":"<ul> <li> <p>El microcontrolador ATtiny88 realiza varias funciones en un solo circuito integrado. Algunos pines del microcontrolador est\u00e1n disponibles con la capacidad de utilizar la funci\u00f3n mencionada anteriormente. Algunas de las principales funciones de este microcontrolador incluyen temporizadores, comunicaci\u00f3n SPI, comunicaci\u00f3n I2C, BOD (Restablecimiento por ca\u00edda de voltaje), interrupci\u00f3n y ADC. Este microcontrolador ATtiny88 incluye diferentes memorias como FLASH, EEPROM y SRAM.</p> </li> <li> <p>El Atmel\u00ae ATtiny88 es un microcontrolador CMOS de 8 bits de bajo consumo de energ\u00eda basado en la arquitectura RISC mejorada AVR\u00ae. Al ejecutar instrucciones potentes en un solo ciclo de reloj, el Atmel ATtiny88 logra un rendimiento cercano a 1MIPS por MHz, lo que permite al dise\u00f1ador del sistema optimizar el consumo de energ\u00eda versus la velocidad de procesamiento.</p> </li> </ul>"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#caracteristicas","title":"CARACTER\u00cdSTICAS:","text":"<ul> <li>Velocidad de reloj: 16 MHz (N\u00famero de ciclos que la CPU ejecuta por segundo).</li> <li>Voltaje de alimentaci\u00f3n: 5V a trav\u00e9s de micro USB, 7-12V en el pin VIN.</li> <li>26 pines de entrada/salida (2 exclusivamente para USB).</li> <li>26 pines de entrada/salida para PWM de software / 2 de ellos PWM (modulaci\u00f3n de ancho de pulso) por hardware (D9-D10).</li> <li>8 entradas anal\u00f3gicas (Las entradas anal\u00f3gicas son terminales o pines en un microcontrolador que permiten la entrada de se\u00f1ales anal\u00f3gicas, un rango de se\u00f1al de varios valores).</li> <li>Interfaz I2C y SPI (La Interfaz de Comunicaci\u00f3n Serial (SPI) y el Circuito Integrado Inter-Interfaz (I2C) son dos protocolos de comunicaci\u00f3n serial comunes utilizados en electr\u00f3nica. Ambos protocolos permiten que m\u00faltiples dispositivos se comuniquen entre s\u00ed y con un microcontrolador o procesador).</li> <li>PWR LED de alimentaci\u00f3n y LED incorporado o prueba \"Pin 0\".</li> <li>Bot\u00f3n de reinicio.</li> <li>Microcontrolador AVR\u00ae de 8 bits con alto rendimiento y bajo consumo de energ\u00eda.</li> <li>Rango de velocidad: 0 a 8 MHz a 2.7-5.5V, 0 a 16 MHz a 4.5-5.5V.</li> <li>Bajo consumo de energ\u00eda: modo activo: 8MHz a 5V-4.4mA, modo de suspensi\u00f3n: a 5V-6 microA.</li> <li>Arquitectura RISC avanzada.</li> <li>123 instrucciones potentes, la mayor\u00eda se ejecutan en un solo ciclo de reloj.</li> <li>32 x 8 registros de trabajo de prop\u00f3sito general.</li> <li>Operaci\u00f3n totalmente est\u00e1tica.</li> <li>Segmentos de memoria no vol\u00e1til de alta resistencia.</li> <li>8K bytes de memoria de programa de flash auto-programable en el sistema (ATtiny88) se refiere a la capacidad de almacenamiento de la memoria de programa de flash en un dispositivo electr\u00f3nico.</li> <li>64 bytes de EEPROM (Memoria de solo lectura programable el\u00e9ctricamente).</li> <li>512 bytes de SRAM interna (Memoria de acceso aleatorio est\u00e1tica). Ciclos de escritura/borrado: 10,000 Flash/100,000 EEPROM.</li> <li>Bloqueo de programaci\u00f3n para seguridad de software. Caracter\u00edsticas perif\u00e9ricas.</li> <li>Un temporizador/contador de 8 bits con preescalador independiente y modo de comparaci\u00f3n.</li> <li>Un temporizador/contador de 16 bits con preescalador y modos de comparaci\u00f3n y captura.</li> <li>Un ADC de 8 canales y 10 bits en paquetes TQFP de 32 terminales y QFN de 32 terminales.</li> <li>Interfaz maestro/esclavo serial SPI.</li> <li>Interfaz serial de 2 cables orientada a bytes (compatible con Phillips I2C).</li> <li>Temporizador de vigilancia programable con oscilador independiente en el chip.</li> <li>Comparador anal\u00f3gico en el chip.</li> <li>Interrupci\u00f3n y activaci\u00f3n por cambio de pin.</li> <li>Caracter\u00edsticas especiales del microcontrolador.</li> <li>Sistema de depuraci\u00f3n en chip debugWIRE.</li> <li>Programable en el sistema a trav\u00e9s del puerto SPI.</li> <li>Restablecimiento de encendido programable y detecci\u00f3n de ca\u00edda de voltaje.</li> <li>Oscilador interno calibrado.</li> <li>Fuentes de interrupci\u00f3n externas e internas.</li> <li>Tres modos de suspensi\u00f3n: Suspensi\u00f3n, reducci\u00f3n de ruido del ADC y apagado.</li> <li>E/S y paquetes.</li> <li>28 l\u00edneas de E/S programables en paquetes TQFP de 32 pines y QFN de 32 pines.</li> <li>Voltaje de funcionamiento: 2.7-5.5V. Rango de temperatura automotriz: -40\u00b0C a +125\u00b0C.</li> </ul>"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#configuracion-de-pines-y-sus-funciones-respectivas","title":"CONFIGURACI\u00d3N DE PINES Y SUS FUNCIONES RESPECTIVAS","text":"<p>Obtenido de: ATtiny88 data sheet</p>"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#data-sheet","title":"DATA SHEET","text":"<p>MH-ATtiny88</p>"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#identicacion-de-pines","title":"IDENTICACION DE PINES","text":"<p>Descripci\u00f3n de los pines y su designaci\u00f3n:</p> PIN NO. NAME FUNCTION 0 D0 DIGITAL PIN, LED 0 1 D1 DIGITAL PIN 2 D2 DIGITAL PIN 3 D3 DIGITAL PIN 4 D4 DIGITAL PIN 5 D5 DIGITAL PIN 6 D6 DIGITAL PIN 7 D7 DIGITAL PIN 8 D8 DIGITAL PIN 9 D9 DIGITAL PIN 10 D10 DIGITAL PIN,SS 11 D11 DIGITAL PIN,MOSI 12 D12 DIGITAL PIN,MISO 13 D13 DIGITAL PIN,SCK 14 D14 DIGITAL PIN 15 D15 DIGITAL PIN 16 D16 DIGITAL PIN 17 D17, A6 DIGITAL PIN, analog-to-digital converter 18 D18, A7 DIGITAL PIN, analog-to-digital converter 19 D19, A0 DIGITAL PIN, analog-to-digital converter 20 D20, A1 DIGITAL PIN, analog-to-digital converter 21 D21, A2 DIGITAL PIN, analog-to-digital converter 22 D22, A3 DIGITAL PIN, analog-to-digital converter 23 D23, A4 DIGITAL PIN, analog-to-digital converter,SDA 24 D24, A5 DIGITAL PIN, analog-to-digital converter,SCL 25 D25 DIGITAL PIN RST RESET VIN POWER SUPPLY: VIN 7-12V 5V POWER SUPPLY: 5V GND GROUND"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#configuracion-de-los-puerto-de-lectura-analogica","title":"Configuraci\u00f3n de los Puerto de Lectura Anal\u00f3gica","text":"PIN NO. NOMBRE DECLARACION 17 A6 1 18 A7 2 19 A0 -5 20 A1 -4 21 A2 -3 22 A3 -2 23 A4 -1 24 A5 0"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#programacion-en-lenguaje-v","title":"PROGRAMACION EN LENGUAJE V","text":"<p>Las funciones descriptivas contenidas en la API como entradas o salidas que realizan la conversi\u00f3n anal\u00f3gico a digital:</p> NAME DESCRIPTION <code>pin.setup(pin, mode)</code> Configurar pin como: <code>mode (input, out)</code> <code>pin.high(pin)</code> Salida digital On <code>high pin</code> <code>pin.low(pin)</code> Salida digital Off<code>low pin</code> <code>pin.write(pin, val)</code> ingresar el valor en <code>pin</code> <code>pin.read(pin)</code> Entrada digital <code>pin</code> <code>adc.read(pin)</code> Lectura de pin anal\u00f3gico para ADC <code>pwm.write(pin, val)</code> Pin de salida y un ciclo de valor \u00fatil <code>uart.setup(baund_rate)</code> Inicio de comunicaci\u00f3n serial <code>uart.read()</code> Lectura de Comunicaci\u00f3n Serial <code>println(message)</code> Imprimir mensaje a trav\u00e9s de la Comunicaci\u00f3n Serial <code>time.sleep(time)</code> retardo en <code>S</code> <code>time.sleep_us(time)</code> retardo en <code>uS</code> <code>time.sleep_ms(time)</code> retardo en <code>mS</code> <code>input</code> Parametros <code>mode</code> configuracion de entrada <code>output</code> parametros <code>mode</code> configuracion de salida <code>uart.any()</code> Obtener el n\u00famero de bytes para leer <ul> <li>La siguiente tabla presentar\u00e1 las equivalencias entre las funciones nativas del compilador en contraste con aquellas implementadas en el proyecto Aixt, con la idea central de redefinir estas funciones y ofrecer soporte estandarizado.</li> </ul> DEFINITION AIXT DEFINITION ARDUINO <code>adc.read(PIN_NAME)</code> <code>analogRead(PIN_NAME)</code> <code>pin.high(PIN_NAME)</code> <code>digitalWrite(PIN_NAME, HIGH)</code> <code>pin.low(PIN_NAME)</code> <code>digitalWrite(PIN_NAME, LOW)</code> <code>output</code> <code>OUTPUT</code> <code>input</code> <code>INPUT</code> <code>input_pullup   INPUT_PULLUP</code> <code>pin.read(PIN_NAME)</code> <code>digitalRead(PIN_NAME)</code> <code>pin.setup(pin_name, mode)</code> <code>pinMode(PIN_NAME, MODE)</code> <code>pin.write(PIN_NAME, VALUE)</code> <code>digitalWrite(PIN_NAME, VALUE)</code> <code>pwm.write(PIN, VALUE)</code> <code>analogWrite(PIN, VALUE)</code> <code>time.sleep_ms(MS)</code> <code>delay(MS)</code> <code>time.sleep_us(US)</code> <code>delayMicroseconds(US)</code> <code>time.sleep(S)</code> <code>delay(S*1000)</code> <code>uart.any_0()</code> <code>Serial.available()</code> <code>uart.any_1()</code> <code>Serial1.available()</code> <code>uart.any_x(UART_NUMBER)    uart.any ## UART_NUMBER ##</code> <code>serial.available()</code> <code>uart.print_0(MESSAGE)</code> <code>Serial.print(MESSAGE)</code> <code>uart.print_1(MESSAGE)</code> <code>Serial1.print(MESSAGE)</code> <code>uart.println_0(MESSAGE)</code> <code>Serial.println(MESSAGE)</code> <code>uart.println_1(MESSAGE)</code> <code>Serial1.println(MESSAGE)</code> <code>uart.read_0()</code> <code>Serial.read()</code> <code>uart.read_1()</code> <code>Serial1.read()</code> <code>uart.setup(BAUD_RATE)</code> <code>Serial.begin(BAUD_RATE)</code> <code>*Table of equivalences between functions</code>"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#ejemplos","title":"ejemplos","text":"<ul> <li>Adici\u00f3n de ejemplos de c\u00f3digo en el lenguaje V que pueden implementarse en el proyecto Aixt para pruebas y traducci\u00f3n:</li> </ul>"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#parpadeo-led","title":"parpadeo led","text":"<p>Parpadeo de un LED en un ciclo infinito con retraso de tiempo:</p> <pre><code>import time { sleep_ms }            // importa (sleep_ms) del modulo time\nimport pin                      // importa el modulo pin en su totalidad\n\npin.setup(1, pin.output)            // configura el pin 1 como salida\nfor {                               //crea el void loob\n    pin.high(1)                 //pin encendido\n    time.sleep_ms(500)                  //retardo en milisegundos \n    pin.low(1)                  //pin apagado\n    time.sleep_ms(500)                   //retardo en milisegundos\n}\n</code></pre>"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#secuencia-tipo-semaforo","title":"Secuencia tipo semaforo","text":"<pre><code>import time {sleep_ms}          //importa la funcion sleep_ms de el modulo time   \nimport pin          // Importa el m\u00f3dulo pin en su totalidad\n\npin.setup(14, pin.output)       // Establece el pin #14 como salida\npin.setup(15, pin.output)       // Establece el pin #15 como salida\npin.setup(16, pin.output)       // Establece el pin #16 como salida\n\nfor{\n    pin.high(14)        // salida 14 high   \n    sleep_ms(2000)      // retardo de 2000 ms\n    pin.low(14)         // salida 14 baja\n    pin.high(15)            // salida 15 high\n    sleep_ms(2000)      // retardo de 2000 ms   \n    pin.low(15)         // salida 15 baja\n    pin.high(16)            // salida 16 high \n    sleep_ms(2000)          // retardo de 2000 ms\n    pin.low(16)         // salida 15 baja\n}\n</code></pre>"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#lectura-analogica-y-digital","title":"LECTURA ANAL\u00d3GICA Y DIGITAL","text":"<p>En este ejemplo, probaremos las lecturas anal\u00f3gicas y digitales a trav\u00e9s del destello de un LED que depende de la variaci\u00f3n de un potenci\u00f3metro:</p> <pre><code>import pin                            // Importa el m\u00f3dulo pin en su totalidad\nimport adc                            // Importa el m\u00f3dulo adc en su totalidad\nimport pwm                            // Importa el m\u00f3dulo pwm en su totalidad\n\n__global (\n    brillo = 0                        // crea una variable global\n    )\n\n\n\nfor{                      // crea el ciclo\n  brillo=adc.read(-5)     //lee la entrada anologa digital\n    pwm.write(3,brillo)   //escribe la salida pwm\n}\n</code></pre>"},{"location":"repoFer/Atmel/MH-ATtiny88/guiarapida/#comunicacion-serial","title":"comunicacion serial","text":"<p>Prueba de comunicaci\u00f3n UART con contador incrementando si se presiona un interruptor:</p> <pre><code>\nimport pin             //importa en su totalidad el modulo PIN\nimport uart            //importa el modulo UART\n\n__global(\nbutton:=0              //define una variable global y la inicia en 0\n        )\n\n\nfor {                   //crea el ciclo\n\n    if pin.read(3) == 1  \n    { \n        button=button+1 \n        uart.print(button)\n    }\n}\n</code></pre> <p>A continuaci\u00f3n, puedes ver un video explicativo de la transcompilaci\u00f3n o traducci\u00f3n del proyecto Aixt. Este video trata sobre la prueba de modulaci\u00f3n de ancho de pulso o PWM, donde se var\u00eda el flujo luminoso de un LED (diodo emisor de luz) mediante la variaci\u00f3n de un potenci\u00f3metro o resistor variable. Los pines se leen y escriben con funci\u00f3n anal\u00f3gico-digital.  Link Youtube : ATtiny88 test PWM-ADC</p>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/","title":"QUICK GUIDE MH-ATTINY88","text":"<p>Implementation of Aixt to support the MH-ATtiny88 card.</p>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#summary","title":"SUMMARY","text":"<ul> <li> <p>The ATtiny88 microcontroller is a small, high performance AVR microcontroller using a RISC processor. This microcontroller comes in two packages that are mainly used for interfacing and control between different sensors and devices.</p> </li> <li> <p>This microcontroller is available with low power consumption through MSSP and 10-bit ADC. The instruction code of this microcontroller can be stored through SRAM - 512 bytes and EEPROM - 64 bytes, manufactured by Micro Ship Tecnologic.</p> </li> <li> <p>Device designed for embedded applications. It is based on the 8-bit AVR architecture and features a wide range of integrated peripherals, including GPIO ports, serial communication interfaces, timers and analog-to-digital converters. The MH-AT-tiny88 is suitable for a variety of applications, from basic control systems to portable devices and IoT sensors due to its combination of compact size, low power consumption and versatile functionality.</p> </li> </ul>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#the-functions","title":"THE FUNCTIONS:","text":"<ul> <li> <p>The ATtiny88 microcontroller performs several functions on a single integrated circuit. Some pins of the microcontroller are available with the ability to use the above function. Some of the main functions of this microcontroller include timers, SPI communication, I2C communication, BOD (Brown Out Reset), interrupt and ADC. This ATtiny88 microcontroller includes different memories such as FLASH, EEPROM and SRAM.</p> </li> <li> <p>The Atmel\u00ae ATtiny88 is a low-power 8-bit CMOS microcontroller based on the AVR\u00ae enhanced RISC architecture. By executing powerful instructions in a single clock cycle, the Atmel ATtiny88 achieves performances close to 1MIPS per MHz, allowing the system designer to optimize power consumption versus processing speed.</p> </li> </ul>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#features","title":"FEATURES:","text":"<ul> <li>Clock speed: 16Mhz (Number of cycles the CPU executes per second). </li> <li>Power supply voltage: 5V via micro USB, 7-12V VIN pin. </li> <li>26 input/output pins (2 exclusively for USB).  </li> <li>26 input/output pins for software PWM / 2 of them PWM (pulse width modulation) by hardware (D9-D10). </li> <li>8 analog inputs (Analog inputs are terminals or pins on a microcontroller that allow input of analog signals, a signal range of various values). </li> <li>12c and SPI interface (The Serial Communication Interface (SPI) and the Inter-Integrated Circuit (I2C) are two common serial communication protocols used in    electronics. Both protocols allow multiple devices to communicate with each other and with a microcontroller or processor). </li> <li>PWR led and Builtin led or \"Pin 0\" test. </li> <li>Reset button.  </li> <li>8-bit AVR\u00ae microcontroller with high performance and low power consumption. </li> <li>Speed range: 0 to 8Mhz at 2.7-5.5V, 0 to 16 Mhz at 4.5-5.5V.</li> <li>Low power consumption: active mode: 8Mhz at 5V-4.4mA, sleep mode: at 5V-6microA. </li> <li>Advanced RISC architecture. </li> <li>123 powerful instructions - most execute in a single clock cycle. </li> <li>32 x 8 general-purpose working registers. </li> <li>Fully static operation. </li> <li>High endurance non-volatile memory segments. </li> <li>8K bytes of self-programmable flash program memory in the system (ATtiny88) refers to the storage capacity of the flash program memory in an electronic device. </li> <li>64 bytes of EEPROM (Electrically Erasable Programmable Read-Only Memory). </li> <li>512 bytes of internal SRAM (Static Random-Access Memory). </li> <li>Write/erase cycles: 10,000 Flash/100,000 EEPROM. </li> <li>Programming lock for software security. </li> <li>Peripheral features. </li> <li>One 8-bit timer/counter with independent prescaler and compare mode. </li> <li>One 16-bit timer/counter with prescaler and compare and capture modes. </li> <li>An 8-channel, 10-bit ADC in 32-terminal TQFP and 32-terminal QFN packages. </li> <li>Serial SPI master/slave interface. </li> <li>2-wire byte-oriented serial interface (Phillips I2C compatible). </li> <li>Programmable watchdog timer with independent on-chip oscillator. </li> <li>On-chip analog comparator. </li> <li>Interruption and activation by pin change.</li> <li>Special features of the microcontroller. </li> <li>On-chip debugging system debugWIRE. </li> <li>On-system programmable through SPI port. </li> <li>Programmable power-on reset and brownout detection. </li> <li>Internal calibrated oscillator. </li> <li>External and internal interrupt sources. </li> <li>Three sleep modes: Sleep, ADC noise reduction and shutdown. </li> <li>I/O and packages. </li> <li>28 programmable I/O lines in 32-pin TQFP and 32-pin QFN package. </li> <li>Operating voltage: 2.7- 5.5V. </li> <li>Automotive temperature range: -40\u00b0C to +125\u00b0C. </li> </ul>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#configuration-of-pins-and-their-respective-functions","title":"CONFIGURATION OF PINS AND THEIR RESPECTIVE FUNCTIONS","text":"<p>Retrieved from: ATtiny88 data sheet</p>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#data-sheet","title":"DATA SHEET","text":"<p>MH-ATtiny88</p>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#pin-identification","title":"PIN IDENTIFICATION","text":"<p>Description of pins and their designation:</p> PIN NO. NAME FUNCTION 0 D0 DIGITAL PIN, LED 0 1 D1 DIGITAL PIN 2 D2 DIGITAL PIN 3 D3 DIGITAL PIN 4 D4 DIGITAL PIN 5 D5 DIGITAL PIN 6 D6 DIGITAL PIN 7 D7 DIGITAL PIN 8 D8 DIGITAL PIN 9 D9 DIGITAL PIN 10 D10 DIGITAL PIN,SS 11 D11 DIGITAL PIN,MOSI 12 D12 DIGITAL PIN,MISO 13 D13 DIGITAL PIN,SCK 14 D14 DIGITAL PIN 15 D15 DIGITAL PIN 16 D16 DIGITAL PIN 17 D17, A6 DIGITAL PIN, analog-to-digital converter 18 D18, A7 DIGITAL PIN, analog-to-digital converter 19 D19, A0 DIGITAL PIN, analog-to-digital converter 20 D20, A1 DIGITAL PIN, analog-to-digital converter 21 D21, A2 DIGITAL PIN, analog-to-digital converter 22 D22, A3 DIGITAL PIN, analog-to-digital converter 23 D23, A4 DIGITAL PIN, analog-to-digital converter,SDA 24 D24, A5 DIGITAL PIN, analog-to-digital converter,SCL 25 D25 DIGITAL PIN RST RESET VIN POWER SUPPLY: VIN 7-12V 5V POWER SUPPLY: 5V GND GROUND"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#analog-readout-port-configuration","title":"ANALOG READOUT PORT CONFIGURATION","text":"PIN NO. NOMBRE DECLARACION 17 A6 1 18 A7 2 19 A0 -5 20 A1 -4 21 A2 -3 22 A3 -2 23 A4 -1 24 A5 0"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#programming-language-v","title":"PROGRAMMING LANGUAGE V","text":"<p>The descriptive functions contained in the API as inputs or outputs that perform analog-to-digital conversion:</p> NAME DESCRIPTION <code>pin.setup(pin, mode)</code> Configure pin like <code>mode (input, out)</code> <code>pin.high(pin)</code> Digital output on <code>high pin</code> <code>pin.low(pin)</code> Digital output on <code>low pin</code> <code>pin.write(pin, val)</code> Type val in <code>pin</code> <code>pin.read(pin)</code> Digital input <code>pin</code> <code>adc.read(pin)</code> Analog pin readout for adc <code>pwm.write(pin, val)</code> Output pin and a useful val cycle <code>uart.setup(baund_rate)</code> Initiation Serial Communication to Baund_rate <code>uart.read()</code> Serial Communication Reading <code>println(message)</code> Print message via Serial Communication <code>time.sleep(time)</code> delay in <code>S</code> <code>time.sleep_us(time)</code> delay in <code>uS</code> <code>time.sleep_ms(time)</code> delay in <code>mS</code> <code>input</code> Parameter <code>mode</code> input configuration <code>output</code> Parameter <code>mode</code> output configuration <code>uart.any()</code> Get the number of bytes to read <ul> <li>The following table will present equivalences between the native functions of the compiler in contrast to those implemented in the Aixt project, with the central idea being to redefine these functions and offer standardized support.</li> </ul> DEFINITION AIXT DEFINITION ARDUINO <code>adc.read(PIN_NAME)</code> <code>analogRead(PIN_NAME)</code> <code>pin.high(PIN_NAME)</code> <code>digitalWrite(PIN_NAME, HIGH)</code> <code>pin.low(PIN_NAME)</code> <code>digitalWrite(PIN_NAME, LOW)</code> <code>output</code> <code>OUTPUT</code> <code>input</code> <code>INPUT</code> <code>input_pullup   INPUT_PULLUP</code> <code>pin.read(PIN_NAME)</code> <code>digitalRead(PIN_NAME)</code> <code>pin.setup(pin_name, mode)</code> <code>pinMode(PIN_NAME, MODE)</code> <code>pin.write(PIN_NAME, VALUE)</code> <code>digitalWrite(PIN_NAME, VALUE)</code> <code>pwm.write(PIN, VALUE)</code> <code>analogWrite(PIN, VALUE)</code> <code>time.sleep_ms(MS)</code> <code>delay(MS)</code> <code>time.sleep_us(US)</code> <code>delayMicroseconds(US)</code> <code>time.sleep(S)</code> <code>delay(S*1000)</code> <code>uart.any_0()</code> <code>Serial.available()</code> <code>uart.any_1()</code> <code>Serial1.available()</code> <code>uart.any_x(UART_NUMBER)    uart.any ## UART_NUMBER ##</code> <code>serial.available()</code> <code>uart.print_0(MESSAGE)</code> <code>Serial.print(MESSAGE)</code> <code>uart.print_1(MESSAGE)</code> <code>Serial1.print(MESSAGE)</code> <code>uart.println_0(MESSAGE)</code> <code>Serial.println(MESSAGE)</code> <code>uart.println_1(MESSAGE)</code> <code>Serial1.println(MESSAGE)</code> <code>uart.read_0()</code> <code>Serial.read()</code> <code>uart.read_1()</code> <code>Serial1.read()</code> <code>uart.setup(BAUD_RATE)</code> <code>Serial.begin(BAUD_RATE)</code> <code>*Table of equivalences between functions</code>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#code-samples","title":"CODE SAMPLES","text":"<p>Addition of V language examples which can be implemented in the Aixt project for testing and translation:</p>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#blink-of-led","title":"BLINK OF LED","text":"<p>Flashing of one LED in an infinite cycle with time delay:</p> <pre><code>import time { sleep_ms }            // import the time module from the API\nimport pin                      // import the pin module from the API\n\npin.setup(1, pin.output)            // configures pin number 1 as output \n\nfor {                               //main loop of the code \n    pin.high(1)                 //pin high\n    time.sleep_ms(500)                  //delay in seconds \n    pin.low(1)                  //pin low\n    time.sleep_ms(500)                   //delay in seconds\n}\n</code></pre>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#digital-readout","title":"DIGITAL READOUT","text":"<p>Example of digital readout, led sequence:</p> <pre><code>import time {sleep_ms}                    // import the sleep_ms function of the time module \nimport pin                           // Import the pin module in its entirety\n\npin.setup(14, pin.output)       // Set pin #14 as output\npin.setup(15, pin.output)       // Set pin #15 as output\npin.setup(16, pin.output)       // Set pin #16 as output\n\nfor{\n    pin.high(14)          // output 14 high   \n    sleep_ms(2000)        // delay of 2000 ms\n    pin.low(14)           // output 14 low\n    pin.high(15)              // output 15 high\n    sleep_ms(2000)        // delay of 2000 ms   \n    pin.low(15)           // output 15 low\n    pin.high(16)              // output 16 high \n    sleep_ms(2000)            // retardo de 2000 ms\n    pin.low(16)           // output 15 baja\n}\n</code></pre>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#analog-and-digital-readout","title":"ANALOG AND DIGITAL READOUT","text":"<p>In this example we will test the analog and digital readings through the flashing of a LED that depends on the variation of a variable resistor:</p> <pre><code>import pin                            // Import the pin module in its entirety\nimport adc                            // Import the adc module in its entirety\nimport pwm                            // Import the pwm module in its entirety\n\n__global (\n    brillo = 0                        // crea una variable global\n    )\n\n\n\nfor{                                    // creates the cycle\n  brillo=adc.read(-5)                    //read digital anologa entry\n    pwm.write(3,brillo)                   //write the pwm output\n}\n\n</code></pre>"},{"location":"repoFer/Atmel/MH-ATtiny88/quickref/#serial-communication","title":"SERIAL COMMUNICATION","text":"<p>Test UART communication with counter increasing if switch is pressed:</p> <pre><code>\nimport pin             //import the module pin from API\nimport uart            //import the module uart from API\n\n__global(\nbutton:=0              //defined global variable initialized to 0\n        )\n\n\nfor {                   //for loop that executes the main code\n\n    if pin.read(3) == 1  \n    { \n        button=button+1 \n        uart.print(button)\n    }\n}\n</code></pre> <ul> <li>Next you can see an explanatory video of transcompilation or translation from the Aixt project, this video is about the pulse width modulation or PWM test, where the luminous flux of a LED light emitting diode is varied, by means of the variation of a variable resistor or potentiometer. The pins are read and written with analog-digital function.</li> </ul> <p>Link Youtube : ATtiny88 test PWM-ADC</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/","title":"Gu\u00eda r\u00e1pida PSoC4","text":"<p>Esta implementaci\u00f3n de Aixt para PSoC 4 da soporte a la tarjeta   CY8CKIT-049-42XX; </p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#identificacion-tarjeta-cy8ckit-049-42xx","title":"Identificaci\u00f3n tarjeta CY8CKIT-049-42XX","text":""},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#vista","title":"Vista","text":""},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#hoja-de-datos","title":"Hoja de datos","text":"<p>CY8CKIT-049-42XX</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#configuracion-general","title":"Configuraci\u00f3n general","text":"<p>Se integran las funciones b\u00e1sicas del microcontrolados para generar una estructura hardware general, asi;</p> <ul> <li>4 pwms</li> <li>1 leds</li> <li>1 pulsador</li> <li>2 puertos de comunicaci\u00f3n</li> <li>11 entradas digitales</li> <li>11 salidas digitales</li> <li>4 entradas an\u00e1logas</li> </ul> <p>visualizaci\u00f3n en PSoC creator</p> <p></p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#identificacion-de-puertos","title":"Identificaci\u00f3n de puertos","text":"<p>A continuaci\u00f3n se muestran los puertos que se usan y sus debidos nombramientos para la programaci\u00f3n: </p> Puerto nombre Tipo 1.6 led1 salida 0.7 sw1 entrada 0.0 di0 entrada 0.1 di1 entrada 0.2 di2 entrada 0.3 di3 entrada 0.4 di4 entrada 0.5 di5 entrada 0.6 di6 entrada 1.1 di7 entrada 1.3 di8 entrada 1.4 di9 entrada 1.5 di10 entrada 1.7 do0 salida 2.5 do1 salida 2.7 do2 salida 3.0 do3 salida 3.1 do4 salida 3.4 do5 salida 3.5 do6 salida 3.6 do7 salida 3.7 do8 salida 4.2 do9 salida 4.3 do10 salida 1.0 out_pwm0 salida 1.2 out_pwm1 salida 2.4 out_pwm2 salida 2.6 out_pwm3 salida 2.0 in0_adc entrada 2.1 in1_adc entrada 2.2 in2_adc entrada 2.3 in3_adc entrada 4.0 \\uart:rx\\ salida 4.1 \\uart:tx\\ salida"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#programacion-en-lenguaje-v","title":"Programaci\u00f3n en lenguaje v","text":""},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#configuracion-puertos-de-salida","title":"Configuraci\u00f3n puertos de salida","text":"<p>Para activar el puerto que va ha usar;</p> <pre><code>pin.high(pin_name)\n</code></pre> <p>Ejemplo: Si se desea activar el puerto do0;  <code>pin.high(pin.do0)</code>.</p> <p>Para desactivar el puerto que se est\u00e1 usando;</p> <pre><code>pin.low(pin_name)\n</code></pre> <p>Ejemplo: Si se desea desactivar el puerto do0;  <code>pin.low(pin.do0)</code>.</p> <p>Para desactivar o activar el puerto que se va ha usar;</p> <pre><code>pin.write(pin_name, value)\n</code></pre> <p>Ejemplo: Si se desea desactivar el puerto do0;  <code>pin.write(do0, 1)</code>, y si se desea activar;  <code>pin.write(pin.do0, 0)</code>.</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#deteccion-puertos-de-entrada","title":"Detecci\u00f3n puertos de entrada","text":"<p>Si se necesita saber en que estado esta un puerto de entrada:</p> <pre><code>x = pin.read(pin_name)\n</code></pre> <p>Ejemplo: Si se desea detectar el valor del puerto di0; <code>x = pin.read(pin.di0)</code>, y x tomara el valor de 0 o 1, dependiendo el puerto es activo o desactivado.</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#puertos-analogos-a-digital-adc","title":"Puertos an\u00e1logos a digital (ADC)","text":"<p>Para configurar uno de los puertos an\u00e1logos;</p> <pre><code>adc.setup(channel, setup_value_1, ... )\n</code></pre> <p>En channel se introduce el nombre del puerto an\u00e1logo, en setup_value_1 el valor que se le va ha dar ha dicho puerto.</p> <p>Para detectar el valor del puerto an\u00e1logo;</p> <pre><code>x = adc.read(channel)\n</code></pre> <p>En channel se introduce el nombre del puerto an\u00e1logo, y x toma el valor que tenga dicho puerto.</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#pwm","title":"PWM","text":"<p>Para configurar alg\u00fan pwm;</p> <pre><code>pwm.setup(pwm_id, setup_value_1, ... )\n</code></pre> <p>En pwm_id se pone el pwm a usar,  y en setup_value_1 el valor al cual se desea configurar dicho pwm.</p> <p>Ahor, para configurar el ciclo de trabajo de un modulador;</p> <pre><code>pwm_duty(pwm_id, duty)\n</code></pre> <p>En pwm_id se pone el pwm a usar,  y en duty el valor del ciclo (de 0 a 100) en porcentaje.</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#serial-comunication-uart","title":"Serial comunication (UART)","text":"<p>Para configurar un puerto UART;</p> <pre><code>uart.setup(uart_id, baud_rate)\n</code></pre> <p>Aqu\u00ed uart_id es el nombre del puerto que se va ha usar, y baud_rate es el valor de los baudios al cual se va ha usar.</p> <p>Si se requiere ingresar un valor a un puerto UART;</p> <pre><code>x = uart.input(uart_id)\n</code></pre> <p>Donde x es dicho valor.</p> <p>En el caso de que se necesite tomar un valor del puerto UART que se esta usando;</p> <p>-Forma lineal</p> <pre><code>uart.println(uart_id, message)\n</code></pre> <p>Muestra el mensaje (message) de tal forma que un car\u00e1cter sigue al otro.</p> <p>-Forma no lineal</p> <pre><code>uart.print(uart_id, message)\n</code></pre> <p>Muestra el mensaje (message) con saltos de renglon.</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT04942XX/#retardos","title":"Retardos","text":"<p>Uso de tiempos;</p> <p>-Segundos</p> <pre><code>time.sleep(s)\n</code></pre> <p>-milisegundos</p> <pre><code>time.sleep_ms(ms)\n</code></pre> <p>-Microsegundos</p> <pre><code>time.sleep_us(us)\n</code></pre> <p>En cada expresi\u00f3n, el valor del tiempo se pone dentro del parentesis.</p> <p>Ejemplo LED parapadeante</p> <pre><code>import machine { pin }\nimport time { sleep_ms }\n\npin_mode(led1, out)\n\nfor {   //infinite loop\n    pin.high(led1)\n    sleep_ms(500)\n    pin.low(led1)\n    sleep_ms(500)\n}\n</code></pre>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/","title":"Gu\u00eda r\u00e1pida PSoC4","text":"<p>Esta implementaci\u00f3n de Aixt para PSoC 4 da soporte a la tarjeta   CY8CKIT14540XX</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/#identificacion-tarjeta-cy8ckit14540xx","title":"Identificaci\u00f3n tarjeta CY8CKIT14540XX","text":""},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/#vista","title":"Vista","text":""},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/#hoja-de-datos","title":"Hoja de datos","text":"<p>CY8CKIT14540XX</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/#configuracion-general","title":"Configuraci\u00f3n general","text":"<p>Se integran las funciones b\u00e1sicas del microcontrolados para generar una estructura hardware general, asi;</p> <ul> <li>3 pwms</li> <li>9 leds</li> <li>1 pulsador</li> <li>2 puertos de comunicaci\u00f3n</li> <li>3 entradas digitales</li> <li>3 salidas digitales</li> <li>5 sensores capacitivos tipo slider</li> <li>3 sensores capacitivos tipo boton</li> </ul> <p>visualizaci\u00f3n en PSoC creator</p> <p></p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/#identificacion-de-puertos","title":"Identificaci\u00f3n de puertos","text":"<p>A continuaci\u00f3n se muestran los puertos que se usan y sus debidos nombramientos para la programaci\u00f3n: </p> Puerto nombre Tipo 2.5 led1 salida 2.0 led4 salida 2.1 led5 salida 2.2 led6 salida 2.3 led7 salida 2.4 led8 salida 3.4 led9 salida 3.5 led10 salida 3.6 led11 salida 0.7 sw2 entrada 2.7 di0 entrada 0.4 di1 entrada 1.7 di2 entrada 4.0 do0 salida 0.5 do1 salida 3.7 do2 salida 1.2 out_pwm0 salida 2.6 out_pwm1 salida 1.0 out_pwm2 salida 3.0 \\uart:rx\\ salida 3.1 \\uart:tx\\ salida 0.0 SLD0 entrada 0.1 SLD1 entrada 0.2 SLD2 entrada 0.3 SLD3 entrada 0.6 SLD4 entrada 1.4 BTN0 entrada 1.5 BTN1 entrada 1.6 BTN2 entrada"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/#programacion-en-lenguaje-v","title":"Programaci\u00f3n en lenguaje v","text":"<p>Algo importante en esta tarjeta es la activaci\u00f3n de los leds, estos se encienden con ceros logicos, como se puede apreciar en los leds correspondientes a los sensores capacitivos tipo slider:</p> <p></p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/#pin-output","title":"Pin output","text":"<p>Para activar el puerto que va ha usar;</p> <pre><code>pin.high(pin_name)\n</code></pre> <p>Ejemplo: si se desea activar el puerto do0; <code>pin.high(pin.do0)</code>.</p> <p>Para desactivar el puerto que se est\u00e1 usando;</p> <pre><code>pin.low(pin_name)\n</code></pre> <p>Ejemplo: si se desea desactivar el puerto do0; <code>pin.low(pin.do0)</code>.</p> <p>Para desactivar o activar el puerto que se va ha usar;</p> <pre><code>pin.write(pin_name, value)\n</code></pre> <p>Ejemplo: si se desea desactivar el puerto do0;  <code>pin.write(do0, 1)</code>, y si se desea activar;  <code>pin.write(pin.do0, 0)</code>.</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/#deteccion-puertos-de-entrada","title":"Detecci\u00f3n puertos de entrada","text":"<p>Si se necesita saber en que estado esta un puerto de entrada:</p> <pre><code>x = pin.read(pin_name)\n</code></pre> <p>Ejemplo: Si se desea detectar el valor del puerto di0;  <code>x = pin.read(pin.di0)</code>, y x tomara el valor de 0 o 1, dependiendo el puerto es activo o desactivado.</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/#pwm","title":"PWM","text":"<p>Para configurar alg\u00fan pwm;</p> <pre><code>pwm.setup(pwm_id, setup_value_1, ... )\n</code></pre> <p>En pwm_id se pone el pwm a usar,  y en setup_value_1 el valor al cual se desea configurar dicho pwm.</p> <p>Ahora, para configurar el ciclo de trabajo de un modulador;</p> <pre><code>pwm_duty(pwm_id, duty)\n</code></pre> <p>En pwm_id se pone el pwm a usar,  y en duty el valor del ciclo (de 0 a 100) en porcentaje.</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/#serial-comunication-uart","title":"Serial comunication (UART)","text":"<p>Para configurar un puerto UART;</p> <pre><code>uart.setup(uart_id, baud_rate)\n</code></pre> <p>Aqu\u00ed uart_id es el nombre del puerto que se va ha usar, y baud_rate es el valor de los baudios al cual se va ha usar.</p> <p>Si se requiere ingresar un valor a un puerto UART;</p> <pre><code>x = uart.input(uart_id)\n</code></pre> <p>Donde x es dicho valor.</p> <p>En el caso de que se necesite tomar un valor del puerto UART que se esta usando;</p> <p>-Forma lineal</p> <pre><code>uart.println(uart_id, message)\n</code></pre> <p>Muestra el mensaje (message) de tal forma que un car\u00e1cter sigue al otro.</p> <p>-Forma no lineal</p> <pre><code>uart.print(uart_id, message)\n</code></pre> <p>Muestra el mensaje (message) con saltos de renglon.</p>"},{"location":"repoFer/Cypress/PSoC4/CY8CKIT14540XX/#retardos","title":"Retardos","text":"<p>Uso de tiempos;</p> <p>-Segundos</p> <pre><code>time.sleep(s)\n</code></pre> <p>-milisegundos</p> <pre><code>time.sleep_ms(ms)\n</code></pre> <p>-Microsegundos</p> <pre><code>time.sleep_us(us)\n</code></pre> <p>En cada expresi\u00f3n, el valor del tiempo se pone dentro del parentesis.</p> <p>Ejemplo LED parapadeante</p> <pre><code>import machine { pin }\nimport time { sleep_ms }\n\npin_mode(led1, out)\n\nfor {   //infinite loop\n    pin.high(led1)\n    sleep_ms(500)\n    pin.low(led1)\n    sleep_ms(500)\n}\n</code></pre>"},{"location":"repoFer/Emulator/quickref/","title":"Quick reference for the Software Emulator","text":"<p>Software CLI emulator that works on Linux, Windows and Android (Termux).</p>"},{"location":"repoFer/Emulator/quickref/#delay","title":"Delay","text":"<p>Use the <code>time</code> module:</p> <pre><code>import time\n\ntime.sleep(2)            // sleep for 2 seconds\ntime.sleep_ms(50)        // sleep for 50 milliseconds\ntime.sleep_us(100)       // sleep for 100 microseconds\n</code></pre>"},{"location":"repoFer/Emulator/quickref/#functions","title":"Functions","text":"name description <code>time.sleep(time)</code> delay in seconds <code>time.sleep_us(time)</code> delay in microseconds <code>time.sleep_ms(time)</code> delay in milliseconds"},{"location":"repoFer/Emulator/quickref/#emulated-pins","title":"Emulated pins","text":"<p>Use the <code>pin</code> module:</p> <pre><code>import pin\n\npin.high(pin.x)\npin.low(pin.y)\npin.write(pin.z, pin.read(pin.a))   // pin echo\n</code></pre>"},{"location":"repoFer/Emulator/quickref/#functions_1","title":"Functions","text":"name description <code>pin.high(pin)</code> Turn ON <code>pin</code> <code>pin.low(pin)</code> Turn OFF <code>pin</code> <code>pin.write(pin, value)</code> Write <code>value</code> in <code>pin</code> <code>pin.read(pin)</code> Return the state of <code>pin</code>"},{"location":"repoFer/Emulator/quickref/#digital-pin-names","title":"Digital pin names","text":"<p>The functions to emulate input/output digital pins on the terminal use 8 emulated pins named: <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>w</code>, <code>x</code>, <code>y</code> and <code>z</code>, which are show in the terminal after any change, as follows:</p> <p>After calling a writing function</p> <pre><code> Aixt virtual pins     [#] = ON   [ ] = OFF\n _____ _____ _____ _____ _____ _____ _____ _____\n|  a  |  b  |  c  |  d  |  w  |  x  |  y  |  z  |\n| [#] | [ ] | [ ] | [ ] | [ ] | [#] | [ ] | [ ] |\n'-----'-----'-----'-----'-----'-----'-----'-----'\n</code></pre> <p>After calling a reading function</p> <pre><code> Aixt virtual pins     Input z : 1\n</code></pre> <p>Note: when using <code>pin.read()</code> the user has to write the value in the terminal manually.</p>"},{"location":"repoFer/Emulator/quickref/#emulated-pwm-pulse-width-modulation","title":"Emulated PWM (Pulse Width Modulation)","text":"<p>Use the <code>pwm</code> module:</p> <pre><code>import pwm\n\npwm.write(pwm.ch0, 40)       // set the duty cycle for PWM channel 0\npwm.write(pwm.ch1, 60)       // set the duty cycle for PWM channel 1\n</code></pre> <p>terminal output:</p> <pre><code> Aixt virtual PWM outputs\n                                    PWM 0 :  40 %\n||||||||||||||||||||______________________________\n                                    PWM 1 :  60 %\n||||||||||||||||||||||||||||||____________________\n</code></pre>"},{"location":"repoFer/Emulator/quickref/#functions_2","title":"Functions","text":"name description <code>pwm.write(channel, value)</code> Write <code>value</code> in the PWM <code>channel</code>"},{"location":"repoFer/Emulator/quickref/#pwm-pin-names","title":"PWM pin names","text":"<p>There are 2 emulated PWM channels named: <code>ch0</code> and <code>ch1</code>.</p>"},{"location":"repoFer/Emulator/quickref/#emulated-adc-analog-to-digital-converter","title":"Emulated ADC (Analog to Digital Converter)","text":"<p>Use the <code>adc</code> module:</p> <pre><code>import adc\n\nval1 := adc.read(ch0)       // read de ADC channel 0\nval2 := adc.read(ch1)       // read de ADC channel 1\n</code></pre> <p>terminal output:</p> <pre><code>Aixt virtual ADC input     ADC 0 : 23\n</code></pre> <pre><code>Aixt virtual ADC input     ADC 1 : 56\n</code></pre>"},{"location":"repoFer/Emulator/quickref/#functions_3","title":"Functions","text":"name description <code>adc.read(channel)</code> Return the ADC value in <code>channel</code>"},{"location":"repoFer/Emulator/quickref/#analog-channels","title":"Analog channels","text":"<p>There are 2 emulated ADC channels named: <code>ch0</code> and <code>ch1</code>.</p>"},{"location":"repoFer/Emulator/quickref/#emulated-uart-serial-port","title":"Emulated UART (serial port)","text":"<p>This software emulator has 3 virtual UARTs named <code>UART</code>, <code>UART2</code> and <code>UART3</code>.</p> <p>Use the <code>uart</code> or <code>uartx</code> module:</p> <pre><code>import uart\n\nuart.print('Hello ')\nuart.println('World...')\n</code></pre> <p>terminal output:</p> <pre><code> Aixt virtual UART\nHello world!\n</code></pre>"},{"location":"repoFer/Emulator/quickref/#functions_4","title":"Functions","text":"name description <code>uart.print(message)</code> Print the <code>message</code> in the virtual UART <code>uart.println(message)</code> Print the <code>message</code> plus a new line in the virtual UART <code>uart.input(message)</code> Print the <code>message</code> and return the string entered by the user in the virtual UART <code>uart2.print(message)</code> Print the <code>message</code> in the virtual UART 2 <code>uart2.println(message)</code> Print the <code>message</code> plus a new line in the virtual UART 2 <code>uart2.input(message)</code> Print the <code>message</code> and return the string entered by the user in the virtual UART 2 <code>uart3.print(message)</code> Print the <code>message</code> in the virtual UART 3 <code>uart3.println(message)</code> Print the <code>message</code> plus a new line in the virtual UART 3 <code>uart3.input(message)</code> Print the <code>message</code> and return the string entered by the user in the virtual UART 3"},{"location":"repoFer/Emulator/quickref/#input-function","title":"Input function","text":"<p>The input strings to be captured by the <code>uart.input()</code> function having a fixed size of 30 characters.</p>"},{"location":"repoFer/Luatos/AIR32F103/quickref/","title":"*Fast guide STM32F103C","text":"<p>This Aixt implementation that supports the card  Blue Pill STM32F103C</p>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#id-card-stm32f103c","title":"ID card STM32F103C","text":""},{"location":"repoFer/Luatos/AIR32F103/quickref/#view","title":"View","text":"<ul> <li>AIR32F103C, a total of 44 interfaces are connected, for example, the pin function definition table is the interface definition.</li> </ul> <p> Image taken from the device datasheet</p>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#datasheet","title":"Datasheet","text":"<p>AIR32F103C To program the card STM32F103C, the ST must be connected,therefore, it is recommended to see the datasheet: ST LINK-V2</p>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#port-identification","title":"Port Identification","text":"<p>Below are the ports used and their proper designations for programming:</p> No. Name Function 1 PC14 OSC32_IN 2 PC15 OSC32_OUT 3 GND GROUND CARD BLUE PILL AIR32F103C 4 5V INPUT 5V BLUE PILL AIR32F103C 5 PA0 WKUP/USART2_CTS/ADC12_IN0/TIM2_CH1_ETR/TIM5_CH1 6 PA1 USART2_RTS/ADC12_IN1/TIM2_CH2/TIM5_CH2 7 PB9 PWM 8 PB8 TIM4_CH 9 3.3V INPUT 3.3V BLUE PILL AIR32F103C 10 GND GROUND CARD BLUE PILL AIR32F103C 11 PA2 USART2_TX/ADC12_IN2/TIM2_CH3/TIM5_CH3 12 PA3 USART2_RX/ADC12_IN3/TIM2_CH4/TIM5_CH4 13 PA4 SPI1_NSS/USART2_CK/DAC_OUT1/ADC12_IN4 14 PA6 SPI1_MISO/ADC12_IN6/ 15 PA7 SPI1_MOSI/ADC12_IN7/TIM3_CH2 16 PA5 SPI1_SCK/ADC12_IN5/DAC_OUT2 17 3.3V INPUT 3.3V BLUE PILL AIR32F103C 18 GND GROUND CARD BLUE PILL AIR32F103C 19 PB0 ADC12_IN8/TIM3_CH3 20 PB1 ADC12_IN9/TIM3_CH4 21 PB5 I2C1_SMBA/SPI3_MOS 22 PB4 SPI3_MIS 23 5V INPUT 5V BLUE PILL AIR32F103C 24 PWB 25 GND GROUND CARD BLUE PILL AIR32F103C 26 3.3V INPUT 3.3V BLUE PILL AIR32F103C 27 RST OUTPUT RESET 28 PB3 SPI3_SCK 29 PA15 SPI3_NS 30 PA10 UART 0_RX <p>31 |PA9       | UART 0_TX 32 |GND       | GROUND CARD BLUE PILL AIR32F103C 33 |PB6       | I2C1_SCL/TIM4_CH 34 |PB7       | I2C1_SDA/TIM4_CH 35 |PA8       | USART1_CK/TIM1_CH1/MCO 36 |PB15      | SPI2_MOSI/TIM1_CH3N  37 |PB14      | SPI2_MISO/USART3_RTS/TIM1_CH2N 38 |GND       | GROUND CARD BLUE PILL AIR32F103C 39 |PB13      | SPI2_SCK/USART3_CTS/TIM1_CH1N 40 |PB12      | SPI2_NSS/I2C2_SMBA/USART3_CK/TIM1_BKIN 3.3V          | ELECTRICAL POWER SUPPLY 3.3V BLUE PILL AIR32F103C PB14          | ISPI2_MISO/USART3_RTS/TIM1_CH2N PB13          | ISPI2_MISO/USART3_RTS/TIM1_CH1N GND           | GROUND CONNECTOR ST-LINK V2 PC13          | TAMPER-RTC GND           | GROUND CONNECTOR ST-LINK V2 SWDIO|PA13    | SWCLK|PA14    | 3.3V          | ELECTRICAL POWER SUPPLY 3.3V BLUE PILL AIR32F103C PB2           | LED 1 AZUL PB10          | LED 2 VERDE PB11          | LED 3 ROJO</p>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#digital-input-and-output","title":"Digital input and output","text":"<p>To recognize the digital inputs and outputs, the input and output ports of the card are tested respectively. For this, a code is programmed which allows the ports identified in it to be tested one by one (scheme 2). such as: A0,A1,A2,A3,A4,A5,A6,A7,B0,B1,B8,B9, the aforementioned can also be used as outputs since the card pins allow both functions according to how they are cataloged in programming, the difference between these ports or pins will be that some support voltages of exactly 5 volts and others that support voltages lower than 5 volts, for this type of pins that did not support voltages that reached 5 volts, they were tested with a voltage of 3.3 volts, in order to deliver the 3.3 volts and 5 volts to the card, a ST-LINK V2 burner is used which allows us to select between these two voltages which one we want to deliver and allows us to synchronize the program that we have on the card. ARDUINO IDE application 2.2.1 STM32VLD to FLASH board and AIR32F103C board.</p>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#analog-input-and-output","title":"Analog input and output","text":"<p>To determine which are the analog inputs, the same port testing process carried out previously is carried out with the difference that only the ports that allow them to be used to receive and transmit analog signals will be tested, which allow the amplitude and period of the signal to be modified. A signal for this case is reflected when a potentiometer is used, which works as a variable resistor that has a value between 0\u03a9 and 10 k\u03a9 that regulates the level of voltage that will be supplied by this device at the input of our LED. , the LED is protected by a 330\u03a9 resistor, with this circuit which will allow us to observe how the luminous intensity of the LED varies depending on the value of \u03a9 assigned to the potentiometer, during the verification it is obtained that the ports that allow the transfer Analog signals for our AIR32F103C card are A8, A9, A10,B3,B4,B5,B6,B7,B12, B13,B14,B15</p>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#signal-pwm","title":"Signal PWM","text":"<p>To identify the PWM signal port of the AIR32F103 card, the ports of the card are tested to find out which of them provides us with this function, so we can obtain a PWM signal using an analog signal as input modulating the width of the pulses generated by the output ports through, during identification it is obtained that the pins that allow the emission of a PWM signal are A6, A7,A8,A9,A10, B1, B4,B6,B7,B9, for this purpose the programming of a code which allowed the ports identified above to be recognized one by one and which can be seen in (scheme 2).</p>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#uart-communication","title":"UART communication","text":"<p>To establish the ports of the card that allow us to have UART communication, the 3.3 V provided by the AIR32F103 card is used as input, the input voltage is regulated by means of a potentiometer that, by turning its knob and through communication between The cards through the UART port allow LEDs assigned on the STM32F103C card to be turned on and off, when our voltage regulation device is at its minimum resistance value the green LED must be on, when it reaches the average resistance value it must turn on the yellow LED and when it reaches its maximum resistance value the Red LED at the input must turn on, an LED must be connected to each port, to do this these two cards will be connected through the generic UART port, that is, connect the PA9 port (TX) of the AIR32F103C card with port PA10 (RX) of the STM32F103C card and port PA10 (RX) of the AIR32F103C card with port PA9 (TX) of the STM32F103C card.</p>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#programming-in-v-language","title":"Programming in v language","text":"<p>For each of these modules, you will have a file in .c.v format with the same name of the module and in this you will have the text module followed by the name of the module, example: * module pin * module adc * module pwm * module uart</p>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#output-port-configuration","title":"Output port configuration","text":"<p>To activate the port to use</p> <pre><code>pin.setup(pin_name, mode)\n</code></pre> <p>To activate the port to use</p> <pre><code>pin.high(PIN_NAME)\n</code></pre> <ul> <li>Example: If you want to activate the port 17;  <code>pin.high(17)</code>.</li> </ul> <p>To disable the port being used</p> <pre><code>pin.low(PIN_NAME)\n</code></pre> <ul> <li>Example: If you want to disable the port 17;  <code>pin.low(17)</code>.</li> </ul> <p>To disable or enable the port to be used</p> <pre><code>pin.write(PIN_NAME, VALUE)\n</code></pre> <ul> <li>Example: If you want to disable port 17 <code>pin.write(17, 1)</code>, and if you want to activate  <code>pin.write(17, 0)</code>.</li> </ul>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#input-port-detection","title":"Input port detection","text":"<p>If you need to know what state an entry port is in:</p> <pre><code>x = pin.read(PIN_NAME)\n</code></pre> <ul> <li>Example: If you want to detect the VALUE of port 3; <code>x = pin.read(17)</code>, and <code>x</code> will take the VALUE of 0 or 1, depending on which port is active or disabled.</li> </ul>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#analog-to-digital-ports-adc","title":"Analog to digital ports (ADC)","text":"<p>To configure one of the analog ports</p> <pre><code>adc.setup(PIN_NAME, SETUP_VALUE, ... )\n</code></pre> <ul> <li>In PIN_NAME the name of the analog port is entered, in SETUP_VALUE the VALUE that will be given is said port.</li> </ul> <p>To detect the analog port VALUE</p> <pre><code>x = adc.read(PIN_NAME)\n</code></pre> <ul> <li>In <code>PIN_NAME</code> the name of the analog port is entered, and <code>x</code> takes the VALUE of said port..</li> </ul>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#pulse-width-modulation-pwm-outputs","title":"Pulse Width Modulation (PWM outputs)","text":"<p>To configure some PWM</p> <pre><code>pwm.setup(SETUP_VALUE, setup_VALUE_1, ... )\n</code></pre> <ul> <li>In pwm you set the PWM to use, and in SETUP_VALUE the VALUE to which you want to configure said pwm.</li> </ul> <p>To configure the duty cycle of a modulator</p> <pre><code>pwm.write(duty)\n</code></pre> <ul> <li>In PWM the pwm to be used is set, and in <code>duty</code> the VALUE of the cycle (from 0 to 100) in percentage.</li> </ul>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#serial-communication-uart","title":"Serial communication (UART)","text":"<p>The UART used to be the standard stream output, so the functions <code>print()</code>, <code>println()</code> and <code>input()</code> work directly on the default UART. The default UART could change depending on the board or microcontroller, please refer to the specific documentation. The syntax for most of UART functions is: <code>uart_function_name_x()</code>, being <code>x</code> the identifying number in case of multiple UARTs. You can omit the <code>x</code> for referring to the first or default UART, or in the case of having only one.  </p>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#uart-setup","title":"UART setup","text":"<pre><code>uart.setup(BAUD_RATE)   // the same of uart.setup(BAUD_RATE)\n</code></pre> <p>For a second connection it is used as:</p> <pre><code>uart.setup_1(BAUD_RATE)   // the same of uart.setup_1(BAUD_RATE)\n</code></pre> <ul> <li><code>BAUD_RATE</code> configure the communication speed</li> </ul>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#serial-transmitting","title":"Serial transmitting","text":"<pre><code>uart.print(message)      // print a string to the default UART\n</code></pre> <pre><code>uart.println(message)    // print a string plus a line-new character to the default UART\n</code></pre> <pre><code>uart.ready // get everything ready for to UART\n</code></pre> <pre><code>uart.read // receives binary data (in Bytes) to UART\n</code></pre> <pre><code>uart.write(MESSAGE)    // send binary data (in Bytes) to second UART\n</code></pre> <ul> <li>For a second UART, it would be used as follows:</li> </ul> <pre><code>uart.print_1(MESSAGE)    // print a string to the second UART\n</code></pre> <pre><code>uart.println_1(MESSAGE)  // print a string plus a line-new character to the second UART\n</code></pre> <pre><code>uart.write_1(MESSAGE)    // send binary data (in Bytes) to second UART\n</code></pre> <pre><code>uart.ready_1 // get everything ready for to second UART\n</code></pre> <pre><code>uart.read_1 // receives binary data (in Bytes) to second UART\n</code></pre>"},{"location":"repoFer/Luatos/AIR32F103/quickref/#retardos","title":"Retardos","text":"<ul> <li> <p>Use of times</p> <ul> <li>In each expression, the time VALUE is put inside the parentheses.</li> </ul> </li> </ul> <pre><code>time.sleep(S) //Seconds\n</code></pre> <pre><code>time.sleep_ms(MS) //Milliseconds\n</code></pre> <pre><code>time.sleep_us(US) //Microseconds\n</code></pre> <ul> <li>Example flashing LED</li> </ul> <pre><code>import pin\nimport time {sleep_ms}\n\npin.setup(14, pin.output)\n\nfor {   //infinite loop\n    pin.high(14)\n    sleep_ms(500)\n    pin.low(14)\n    sleep_ms(500)\n}\n</code></pre> <ul> <li>Example digital input and output</li> </ul> <pre><code>const int ledPIN1 = PA3; //salida digital al led PA3\n\nconst int intPIN = PA0; //entrada digital al led PA0\nvoid setup() {\n     Serial.begin(9600);\n     // put your setup code here, to run once:\n     pinMode(ledPIN1, pin.OUTput);//led conectado a salida PA3\n      pinMode(intPIN, pin.INput);//interruptor conectado a entrada PA0\n}\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  if (digitalRead(intPIN)==LOW){\n    //INTERRUPTOR PRESIONADO\n  digitalWrite(ledPIN1, LOW); //LED conectado a PA3\n   }\n    else{\n    //interruptor suelto\n\n  digitalWrite(ledPIN1, LOW);  //LED conectado a PA3\n    }  \n delay (1);\n}\n</code></pre> <ul> <li>Example analog input and output and signal PWM </li> </ul> <pre><code>define LED_BUILTIN 2\n\n#include &lt;PWMOutESP32.h&gt; //https://github.com/fellipecouto/PWMOutESP32 [ http://www.efeitonerd.com.br ]\n\n//Resolution between 1 and 16 (bits). Frequency between 1 and 40000 (Hz)\nPWMOutESP32 pwm(10, 5000); //Resolution=10bits, Frequency=5000Hz\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(LED_BUILTIN, pin.OUTput);\n\n  Serial.println(\"\\nPWMOutESP32\");\n  Serial.println(\"Library for controlling ESP32 PWM outputs similar to use on Arduino\");\n  Serial.print(\"Maximum PWM value for the configured resolution: \");\n  Serial.println(pwm.getMaxPWMValue());\n}\n\nvoid loop() {\n\n  for (int fadeValue = 0; fadeValue &lt;= pwm.getMaxPWMValue(); fadeValue++)  {\n    pwm.analogWrite(LED_BUILTIN, fadeValue);\n    delay(2);\n  }\n  delay(500);\n\n   for (int fadeValue = pwm.getMaxPWMValue(); fadeValue &gt;= 0; fadeValue--)  {\n    pwm.analogWrite(LED_BUILTIN, fadeValue);\n    delay(2);\n  }\n  delay(500);\n\n}\n\n\n\n</code></pre> <ul> <li>Example port comunication UART </li> </ul> <pre><code>for AIR32F103 as emisor:\n\nlong Dato;//Dato como entero\nchar EnviaDato;//creacion enviar dato como Char\n\nvoid setup() {\n  // put your setup code here, to run once:\nSerial.begin(9600);//velocidad en Baudios\nSerial.println(\"Inicio de sketch - valores del potenciometro\");\n}\n\nvoid loop() {\n  Dato=analogRead(PA5);//velocidad en Baudios\n  delay(100);\n  Serial.println(Dato);\n  if(Dato &lt;=600){//Valor menor a 400\n  Serial.write('1');//Envia dato 1 a STM32\n  }\n\n else {\n  Serial.write('3');//Envia dato 1 a STM32\n  }\n}\n\nfor AIR32F103 as receptor:\n\nint LEDPinI=PA4;//LEDPinI asignado al pin PA4\nint LEDPinII=PA6;//LEDPinI asignado al pin PA6\nint RecibeDato;\nvoid setup() {\npinMode(LEDPinI,OUTPUT);//LEDPinI asignado\n//como salida\npinMode(LEDPinII,OUTPUT);//LEDPinII asignado\n//como salida\n\nSerial.begin(9600);//Velocidad en Baudios\n}\nvoid loop() {\n  if(Serial.available()&gt;0){//Comparacion serial\n  //Mayor a cero\n    RecibeDato=Serial.read();//Recibe dato STM32\n    delay(100); //Reset 100 ms\n  }\n  switch(RecibeDato){\n    case '1':\n    digitalWrite(LEDPinI,HIGH);//LEDPinI encendido\n    digitalWrite(LEDPinII,LOW);//LEDPinII apagado\n    break;\n    case '2':\n    digitalWrite(LEDPinI,LOW);//LEDPinI apagado\n    digitalWrite(LEDPinII,HIGH);//LEDPinII encendido\n    break;\n\n  }\n}\n\n</code></pre>"},{"location":"repoFer/M0sense/M0sense/","title":"Fast guide M0sense","text":"<p>This Aixt implementation that supports the card  M0sense</p>"},{"location":"repoFer/M0sense/M0sense/#id-card-m0sense","title":"ID card M0sense","text":""},{"location":"repoFer/M0sense/M0sense/#view","title":"View","text":"<ul> <li>M0sense, a total of 38 interfaces are connected, for example, the pin function definition table is the interface definition.</li> </ul>"},{"location":"repoFer/M0sense/M0sense/#datasheet","title":"Datasheet","text":"<p>M0sense</p>"},{"location":"repoFer/M0sense/M0sense/#port-identification","title":"Port Identification","text":"<p>Below are the ports used and their proper designations for programming:</p> No. Name Function 1 IO28 GPIO28 2 3V3 3.3V power supply; The output current of the external power supply is recommended to be above 500mA 3 GND Ground 4 VSYS REF System 5 I02 GPI02/BOOT Button 6 IO0 GPIO0 7 IO1 GPIO1_LCD_CS 8 IO9 GPIO9 9 IO27 GPIO27_SDA 10 IO26 GPIO26_SCL 11 IO25 GPIO25_LEDR_LCD_DC 12 IO24 GPIO25_LEDG_LCD_MOSI 13 IO23 GPIO25_LEDB_LCD_SCLK 14 IO15 GPIO15 15 IO14 GPIO14 16 GND Ground"},{"location":"repoFer/M0sense/M0sense/#programming-in-v-language","title":"Programming in v language","text":""},{"location":"repoFer/M0sense/M0sense/#output-port-configuration","title":"Output port configuration","text":"<p>To activate the port to use</p> <pre><code>pin.high(pin_name)\n</code></pre> <ul> <li>Example: If you want to activate the port IO17;  <code>pin.high(IO17)</code>.</li> </ul> <p>To disable the port being used</p> <pre><code>pin.low(pin_name)\n</code></pre> <ul> <li>Example: If you want to disable the port IO17;  <code>pin.low(IO17)</code>.</li> </ul> <p>To disable or enable the port to be used</p> <pre><code>pin.write(pin_name, value)\n</code></pre> <ul> <li>Example: If you want to disable port IO17 <code>pin.write(IO17, 1)</code>, and if you want to activate  <code>pin.write(IO17, 0)</code>.</li> </ul>"},{"location":"repoFer/M0sense/M0sense/#input-port-detection","title":"Input port detection","text":"<p>If you need to know what state an entry port is in:</p> <pre><code>x = pin.read(pin_name)\n</code></pre> <ul> <li>Example: If you want to detect the value of port IO3; <code>x = pin.read(IO17)</code>, and <code>x</code> will take the value of 0 or 1, depending on which port is active or disabled.</li> </ul>"},{"location":"repoFer/M0sense/M0sense/#analog-to-digital-ports-adc","title":"Analog to digital ports (ADC)","text":"<p>To configure one of the analog ports</p> <pre><code>adc.setup(channel, setup_value_1, ... )\n</code></pre> <ul> <li>In channel the name of the analog port is entered, in setup_value_1 the value that will be given is said port.</li> </ul> <p>To detect the analog port value</p> <pre><code>x = adc.read(channel)\n</code></pre> <ul> <li>In <code>channel</code> the name of the analog port is entered, and <code>x</code> takes the value of said port..</li> </ul>"},{"location":"repoFer/M0sense/M0sense/#pulse-width-modulation-pwm-outputs","title":"Pulse Width Modulation (PWM outputs)","text":"<p>To configure some PWM</p> <pre><code>pwm.setup(setup_value_1, setup_value_2, ... )\n</code></pre> <ul> <li>In pwm you set the PWM to use, and in setup_value_1 the value to which you want to configure said pwm.</li> </ul> <p>To configure the duty cycle of a modulator</p> <pre><code>pwm_duty(duty)\n</code></pre> <ul> <li>In PWM the pwm to be used is set, and in <code>duty</code> the value of the cycle (from 0 to 100) in percentage.</li> </ul>"},{"location":"repoFer/M0sense/M0sense/#serial-communication-uart","title":"Serial communication (UART)","text":"<p>The UART used to be the standard stream output, so the functions <code>print()</code>, <code>println()</code> and <code>input()</code> work directly on the default UART. The default UART could change depending on the board or microcontroller, please refer to the specific documentation. The syntax for most of UART functions is: <code>uartx_function_name()</code>, being <code>x</code> the identifying number in case of multiple UARTs. You can omit the <code>x</code> for referring to the first or default UART, or in the case of having only one.  </p>"},{"location":"repoFer/M0sense/M0sense/#uart-setup","title":"UART setup","text":"<pre><code>uart.setup(baud_rate)   // the same of uart1_setup(baud_rate)\n</code></pre> <ul> <li><code>baud_rate</code> configure the communication speed</li> </ul>"},{"location":"repoFer/M0sense/M0sense/#serial-transmitting","title":"Serial transmitting","text":"<pre><code>print(message)      // print a string to the default UART\n</code></pre> <pre><code>println(message)    // print a string plus a line-new character to the default UART\n</code></pre> <pre><code>uart2_print(message)    // print a string to the UART2\n</code></pre> <pre><code>uart1_println(message)  // print a string plus a line-new character to the UART1\n</code></pre> <pre><code>uart2_write(message)    // send binary data (in Bytes) to UART2\n</code></pre>"},{"location":"repoFer/M0sense/M0sense/#retardos","title":"Retardos","text":"<ul> <li> <p>Use of times</p> <ul> <li>In each expression, the time value is put inside the parentheses.</li> </ul> </li> </ul> <pre><code>time.sleep(s) //Seconds\n</code></pre> <pre><code>time.sleep_ms(ms) //Milliseconds\n</code></pre> <pre><code>time.sleep_us(us) //Microseconds\n</code></pre> <ul> <li>Example flashing LED</li> </ul> <pre><code>import machine { pin }\nimport time { sleep_ms }\n\npin_mode(IO14, out)\n\nfor {   //infinite loop\n    pin.high(IO14)\n    sleep_ms(500)\n    pin.low(IO14)\n    sleep_ms(500)\n}\n</code></pre>"},{"location":"repoFer/Microchip/Explorer-16/quickref/","title":"Quickref","text":""},{"location":"repoFer/Microchip/Explorer-16/quickref/#quick-reference-for-the-exploer-16-boad","title":"Quick reference for the Exploer 16 boad","text":"<p>Development board for Microchip 16-bit microcontrollers. It includes the families: - PIC24: PIC24FJ128GA010 - dsPIC33: dsPIC33FJ256GP710</p>"},{"location":"repoFer/Microchip/Explorer-16/quickref/#pin-names","title":"Pin names","text":"<p>The pin names are named with a letter indicating the port and a number indicating the pin. For example <code>b12</code> indicates de pin 12 of port B. All the names in Aixt are written in lower-case, to follow the V variable naming rules..</p>"},{"location":"repoFer/Microchip/Explorer-16/quickref/#pin-names-for-pic24fj","title":"Pin names for PIC24FJ","text":"port 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 A a0 a1 a2 a3 a4 a5 a6 a7 - a9 a10 - - - a14 a15 B b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 C c0 c1 c2 c3 c4 - - - - - - - c12 c13 c14 c15 D d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 E e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 - - - - - - F f0 f1 f2 f3 f4 f5 f6 f7 f8 - - - f12 f13 - - G g0 g1 g2 g3 g4 g5 g6 g7 g8 g9 - - g12 g13 g14 g15"},{"location":"repoFer/Microchip/Explorer-16/quickref/#pins-names-for-dspic33","title":"Pins names for dsPIC33","text":"port 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 A a0 a1 a2 a3 a4 a5 a6 a7 - a9 a10 - - - a14 a15 B b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 C c0 c1 c2 c3 c4 - - - - - - - c12 c13 c14 c15 D d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 E e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 - - - - - - F f0 f1 f2 f3 f4 f5 f6 f7 f8 - - - f12 f13 - - G g0 g1 g2 g3 g4 g5 g6 g7 g8 g9 - - g12 g13 g14 g15"},{"location":"repoFer/Microchip/Explorer-16/quickref/#explorer16-onboard-components","title":"Explorer16 Onboard components","text":""},{"location":"repoFer/Microchip/Explorer-16/quickref/#onboard-leds","title":"Onboard LEDs","text":"LED name pin 3 led3 a0 4 led4 a1 5 led5 a2 6 led6 a3 7 led7 a4 8 led8 a5 9 led9 a6 10 led10 a7"},{"location":"repoFer/Microchip/Explorer-16/quickref/#onboard-switchs","title":"Onboard switchs","text":"Switch name pin 3 sw3 d6 4 sw4 d13 5 sw5 a7 6 sw6 d7"},{"location":"repoFer/Microchip/Explorer-16/quickref/#onboard-potentiometer","title":"Onboard potentiometer","text":"Potentiometer name pin 1 pot b5"},{"location":"repoFer/Microchip/Explorer-16/quickref/#delay-and-timing","title":"Delay and timing","text":"<pre><code>time.sleep(2)         // sleep for 2 seconds\ntime.sleep_us(1)        // sleep for 1 microsecond\ntime.sleep_ms(500)  // sleep for 500 milliseconds\n</code></pre>"},{"location":"repoFer/Microchip/Explorer-16/quickref/#pin-and-gpio","title":"Pin and GPIO","text":"<pre><code>pin.setup(pin.b5, out)\npin.setup(pin.a2, out)\npin.setup(pin.c10, in)\n\npin.high(pin.b5)\npin.low(pin.b5)\n\npin.write(pin.a2, 0)\npin.write(pin.a2, 1)\n\nx = pin.read(pin.c10)\n</code></pre> <p>Blinking LED example:</p> <pre><code>import time\nimport pin\n\nfor {\n    pin.high(led10)\n    time.sleep_ms(500)\n    pin.low(led10)\n    time.sleep_ms(500)\n}\n</code></pre>"},{"location":"repoFer/Microchip/Explorer-16/quickref/#uart","title":"UART","text":"<pre><code>uart.setup(1, 9600)\n\nuart.put(1, `x`)\ny := uart.get(1)\n\nuart.write(1, 'Hello...')\nmsg := uart.read(1)\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F676/quickref/","title":"Guia R\u00e1pida para PIC16F676","text":""},{"location":"repoFer/Microchip/PIC16/PIC16F676/quickref/#referencia-del-pic16-utilizado-de-la-marca-microchip","title":"Referencia del PIC16 utilizado de la marca MICROCHIP","text":"<ul> <li>PIC16F676</li> </ul> <p>NOTA: Este microcontrolador PIC16F solo cuenta con salidas digitales, entradas digitales y ADC.</p>"},{"location":"repoFer/Microchip/PIC16/PIC16F676/quickref/#nombres-de-los-pines","title":"Nombres de los Pines","text":"<p>Los nombres de los pines se nombran con una letra que indica el puerto y un n\u00famero que indica el pin. Por ejemplo <code>a6</code> indica el pin 6 del puerto A. Todos los nombres en Aixt estan escritos en min\u00fasculas, para seguir V variable naming rules..</p>"},{"location":"repoFer/Microchip/PIC16/PIC16F676/quickref/#nombres-de-los-pines-del-pic16f676","title":"Nombres de los pines del PIC16F676","text":"Puerto 0 1 2 3 4 5 A a0 a1 a2 a3 a4 a5 C c0 c1 c2 c3 c4 c5 <p>En las familias de microcontroladores del PIC16, los registros del puerto se dividen en: </p> <ul> <li><code>TRIS</code> Para configurar cada pin del puerto</li> <li><code>PORT</code> Para gestionar los pines como entradas o salidas</li> </ul> <p>Luego, para facilitar la implementaci\u00f3n (y no generar c\u00f3digo inncesario) de este port Aixt, el nombre de cada pin difiere de su configuraci\u00f3n, entrada y salida como en el siguiente ejemplo: </p> <ul> <li><code>a5_s</code> Nombre del bit para configurar el <code>a5</code> pin como entrada o salida </li> <li><code>a5</code>   Nombre del bit para leer el pin como entrada o salida <code>a5</code></li> </ul>"},{"location":"repoFer/Microchip/PIC16/PIC16F676/quickref/#componentes-integrados","title":"Componentes Integrados","text":"<p>Cuenta con ocho pines analogicas que se encuentran distribuidas entre en el puerto A y el puerto C.</p> Puerto 0 1 2 3 4 5 A AN0 AN1 AN2 - AN3 - C AN4 AN5 AN6 AN7 - -"},{"location":"repoFer/Microchip/PIC16/PIC16F676/quickref/#funciones-soportadas","title":"Funciones soportadas","text":"<p>Las funciones que contiene la API entradas o salidas digitales y para realizar una conversi\u00f3n analogico a digital.</p> name description <code>pin.setup(pin_name, mode)</code> Configura <code>PIN_NAME</code> en <code>PIN_MODE</code> <code>pin.high(PIN_NAME)</code> Encender <code>PIN_NAME</code> <code>pin.low(PIN_NAME)</code> Apagar <code>PIN_NAME</code> <code>pin.write(PIN_NAME,VAL)</code> Escribe <code>VAL</code> en <code>PIN_NAME</code> <code>pin.read(PIN_NAME)</code> lee <code>PIN_NAME</code> <code>pin.digital(PIN)</code> Configura I/0 digitales <code>PIN_NAME</code> <code>pin (PIN)</code> Configura <code>PIN_OUTPUT</code> o <code>PIN_INPUT</code> <code>port</code> Inicializa <code>port</code> <code>port.read(PORT_NAME)</code> Lee <code>PORT_NAME</code> <code>port.setup(PORT_NAME, VALUE)</code> Configura <code>PORT_NAME</code> asigna valor <code>VALUE</code> <code>port.write(PORT_NAME, VALUE)</code> Escribe <code>PORT_NAME</code> en <code>VALUE</code> <code>adc.setup()</code> Configura el <code>adc</code> <code>adc.read(channel)</code> Configura el canal <code>channel</code> del <code>adc</code> <code>adc</code> Inicializa <code>adc</code> <code>time.sleep(time)</code> Retardo en <code>seg</code> <code>time.sleep_us(time)</code> Retardo en <code>microseg</code> <code>time.sleep_ms(time)</code> Retardo en <code>miliseg</code> <code>time</code> Inicializa el <code>time</code>"},{"location":"repoFer/Microchip/PIC16/PIC16F676/quickref/#ejemplos-de-las-diferentes-funciones-de-la-api-en-lenguaje-_aixt_v","title":"Ejemplos de las diferentes funciones de la API en lenguaje _Aixt_v","text":""},{"location":"repoFer/Microchip/PIC16/PIC16F676/quickref/#tiempo","title":"Tiempo","text":"<pre><code>\ntime.sleep(5)   // Tiempo de 5 segundos\ntime.sleep_us(10)   // Tiempo de 10 microsegundos\ntime.sleep_ms(500)  // Tiempo de 500 milisegundos\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F676/quickref/#configuracion-de-pines","title":"Configuraci\u00f3n de pines","text":"<pre><code>\npin.setup(pin.a5, pin.output)      // Funci\u00f3n para configurar el pin como salida \npin.setup(pin.c2, pin.output)      // Funci\u00f3n para configurar el pin como salida\npin.setup(pin.a2, pin.input)    // Funci\u00f3n para configurar el pin como entrada\npin.setup(pin.c4, pin.input)    // Funci\u00f3n para configurar el pin como entrada\n\npin.high(pin.a5)    // Funci\u00f3n para encender el pin           \npin.low(pin.a5)     // Funci\u00f3n para apagar el pin\n\npin.write(pin.a2, 0)  // Funci\u00f3n sobre escribir el pin\npin.write(pin.a2, 1)  // Funci\u00f3n sobre escribir el pin\n\npin.read(pin.a4)      // Funci\u00f3n para leer el pin\npin.read(pin.c3)      // Funci\u00f3n para leer el pin\n\n</code></pre> <p>Ejemplo de prender y apagar un led:</p> <pre><code>\nfor {\n\n    pin.high(pin.c1);\n    sleep_us(500);\n    pin.low(pin.c1);\n    sleep_us(500);\n\n}\n\n</code></pre> <p>Ejemplo de prender y apagar un led con una entrada digital:</p> <pre><code>\npin.digital(); // Todas los pin son I/O digitales\n\nfor {\n\n    if(c2 == 1){        // Condici\u00f3n si encuentra un 1 en el c2\n\n        pin.high(pin.c1);\n        pin.high(pin.c0);\n    }\n\n    else if(c4 == 1){   // Condici\u00f3n si encuentra un 1 en el c4\n\n        pin.low(pin.c1);\n        pin.low(pin.c0);\n    }\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F676/quickref/#configuracion-del-port","title":"Configuraci\u00f3n del port","text":"<pre><code>\nport.setup(port.a, ob000000)      // Funci\u00f3n para configurar el puerto como salida \n\n</code></pre> <p>Ejemplo de prender y apagar un puerto del microcontrolador:</p> <pre><code>\nfor {\n\n    port.write(port.a,0b010101);\n    sleep_ms(500);\n    port.write(port.a,0b101010);\n    sleep_ms(500);      \n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F676/quickref/#configuracion-del-adc","title":"Configuraci\u00f3n del ADC","text":"<pre><code>\nadc.setup()     // Inicializa el ADC\nadc.read(0)     // Escoge el pin del canal analogico\n\n</code></pre> <p>Ejemplo de prender y apagar leds dependiendo del valor del ADC:</p> <pre><code>\nunsigned int adc_result;  // Declaraci\u00f3n de variable para almacenar el valor del ADC\n\nfor {\n\n    adc_result = adc.read(0); // Almacena el valor del ADC\n\n    if ( adc_result &gt;= 1020 ){\n\n        pin.high(pin.c0);\n        pin.high(pin.c1);\n        pin.high(pin.c2);           \n    }\n\n    else if ( adc_result &gt;= 820 ){\n\n        pin.high(pin.c0);\n        pin.high(pin.c1);\n        pin.low(pin.c2);\n    }\n\n    else if ( adc_result &gt;= 620 ){\n\n        pin.high(pin.c0);\n        pin.low(pin.c1);\n        pin.low(pin.c2);   \n    }\n\n    else {\n\n        pin.low(pin.c0);\n        pin.low(pin.c1);\n        pin.low(pin.c2);      \n    }\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/","title":"Guia R\u00e1pida para PIC16F873A","text":""},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#referencia-del-pic16-utilizado-de-la-marca-microchip","title":"Referencia del PIC16 utilizado de la marca MICROCHIP","text":"<ul> <li>PIC16F873A</li> </ul> <p>NOTA: Este microcontrolador PIC16F cuenta con salidas digitales, entradas digitales, ADC, PWM y comunicaci\u00f3n serial.</p>"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#nombres-de-los-pines","title":"Nombres de los Pines","text":"<p>Los nombres de los pines se nombran con una letra que indica el puerto y un n\u00famero que indica el pin. Por ejemplo <code>a6</code> indica el pin 6 del puerto A. Todos los nombres en Aixt estan escritos en min\u00fasculas, para seguir V variable naming rules..</p>"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#nombres-de-los-pines-del-pic16f873a","title":"Nombres de los pines del PIC16F873A","text":"Puerto 0 1 2 3 4 5 6 7 A a0 a1 a2 a3 a4 a5 - - B b0 b1 b2 b3 b4 b5 b6 b7 C c0 c1 c2 c3 c4 c5 c6 c7 <p>En las familias de microcontroladores del PIC16, los registros del puerto se dividen en: </p> <ul> <li><code>TRIS</code> Para configurar cada pin del puerto</li> <li><code>PORT</code> Para gestionar los pines como entradas o salidas</li> </ul> <p>Luego, para facilitar la implementaci\u00f3n (y no generar c\u00f3digo inncesario) de este port Aixt, el nombre de cada pin difiere de su configuraci\u00f3n, entrada y salida como en el siguiente ejemplo: </p> <ul> <li><code>b5_s</code> Nombre del bit para configurar el <code>b5</code> pin como entrada o salida </li> <li><code>b5</code>   Nombre del bit para leer el pin como entrada o salida <code>b5</code></li> </ul>"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#componentes-integrados","title":"Componentes Integrados","text":"<ul> <li>Cuenta con seis pines analogicos que se encuentran distribuidas en el puerto A.</li> </ul> Puerto 0 1 2 3 4 5 6 7 A AN0 AN1 AN2 AN3 AN4 AN5 - - B - - - - - - - - C - - - - - - - - <ul> <li>Cuenta con dos pines para la modulacion del PWM.</li> </ul> Puerto 0 1 2 3 4 5 6 7 A - - - - - - - - B - - - - - - - - C - c1 c2 - - - - - <ul> <li>Cuenta con dos pines para la cominicaci\u00f3n serial.   </li> </ul> Puerto 0 1 2 3 4 5 6 7 A - - - - - - - - B - - - - - - - - C - - - - - - c6 c7"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#funciones-soportadas","title":"Funciones soportadas","text":"<p>Las funciones que contiene la API entradas o salidas digitales, conversor analogico a digital, modulaci\u00f3n pwm y comunicaci\u00f3n serial.</p> name description <code>pin.setup(pin_name, mode)</code> Configura <code>PIN_NAME</code> en <code>PIN_MODE</code> <code>pin.high(PIN_NAME)</code> Encender <code>PIN_NAME</code> <code>pin.low(PIN_NAME)</code> Apagar <code>PIN_NAME</code> <code>pin.write(PIN_NAME,VAL)</code> Escribe <code>VAL</code> en <code>PIN_NAME</code> <code>pin.read(PIN_NAME)</code> lee <code>PIN_NAME</code> <code>pin.digital(PIN)</code> Configura I/0 digitales <code>PIN_NAME</code> <code>pin (PIN)</code> Configura <code>PIN_OUTPUT</code> o <code>PIN_INPUT</code> <code>port</code> Inicializa <code>port</code> <code>port.read(PORT_NAME)</code> Lee <code>PORT_NAME</code> <code>port.setup(PORT_NAME, VALUE)</code> Configura <code>PORT_NAME</code> asigna valor <code>VALUE</code> <code>port.write(PORT_NAME, VALUE)</code> Escribe <code>PORT_NAME</code> en <code>VALUE</code> <code>adc.setup()</code> Configura el <code>adc</code> <code>adc.read(channel)</code> Configura el canal <code>channel</code> del <code>adc</code> <code>adc</code> Inicializa <code>adc</code> <code>pwm.setup()</code> Configura el resgitro <code>pwm</code> <code>pwm.write(duty)</code> Calcula el <code>duty</code> del <code>pwm</code> <code>pwm</code> Inicializa <code>pwm</code> <code>uart.setup()</code> Configura el <code>uart</code> <code>uart.read()</code> Lee los datos del <code>uart</code> <code>uart.write()</code> Escribe los datos del <code>uart</code> <code>uart</code> Inicializa el <code>uart</code> <code>time.sleep(time)</code> Retardo en <code>seg</code> <code>time.sleep_us(time)</code> Retardo en <code>microseg</code> <code>time.sleep_ms(time)</code> Retardo en <code>miliseg</code> <code>time</code> Inicializa el <code>time</code>"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#ejemplos-de-las-diferentes-funciones-de-la-api-en-lenguaje-_aixt_v","title":"Ejemplos de las diferentes funciones de la API en lenguaje _Aixt_v","text":""},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#tiempo","title":"Tiempo","text":"<pre><code>\ntime.sleep(5)   // Tiempo de 5 segundos\ntime.sleep_us(10)   // Tiempo de 10 microsegundos\ntime.sleep_ms(500)  // Tiempo de 500 milisegundos\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#configuracion-de-pines","title":"Configuraci\u00f3n de pines","text":"<pre><code>\npin.setup(pin.a5, pin.output)      // Funci\u00f3n para configurar el pin como salida \npin.setup(pin.b7, pin.output)      // Funci\u00f3n para configurar el pin como salida\npin.setup(pin.a0, pin.input)    // Funci\u00f3n para configurar el pin como entrada\npin.setup(pin.c4, pin.input)    // Funci\u00f3n para configurar el pin como entrada\n\npin.high(pin.a5)    // Funci\u00f3n para encender el pin           \npin.low(pin.a5)     // Funci\u00f3n para apagar el pin\n\npin.write(pin.a2, 0)  // Funci\u00f3n sobre escribir el pin\npin.write(pin.a2, 1)  // Funci\u00f3n sobre escribir el pin\n\npin.read(pin.b4)      // Funci\u00f3n para leer el pin\npin.read(pin.c7)      // Funci\u00f3n para leer el pin\n\n</code></pre> <p>Ejemplo de prender y apagar un led:</p> <pre><code>\nfor {\n\n    pin.high(pin.c7);\n    sleep_us(500);\n    pin.low(pin.c7);\n    sleep_us(500);\n\n}\n\n</code></pre> <p>Ejemplo de prender y apagar un led con una entrada digital:</p> <pre><code>\npin.digital();\n\nfor {\n\n    if(b4 == 1){        // Condici\u00f3n si encuentra un 1 en el c2\n\n        pin.high(pin.a4);\n        pin.high(pin.a5);\n    }\n\n    else if(b5 == 1){   // Condici\u00f3n si encuentra un 1 en el c4\n\n        pin.low(pin.a4);\n        pin.low(pin.a5);\n    }\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#configuracion-del-port","title":"Configuraci\u00f3n del port","text":"<pre><code>\nport.setup(port.b, ob00000000)      // Funci\u00f3n para configurar el puerto como salida \n\n</code></pre> <p>Ejemplo de prender y apagar un puerto del microcontrolador:</p> <pre><code>\nfor {\n\n    port.write(port.b,0b01010101);\n    sleep_ms(500);\n    port.write(port.b,0b10101010);\n    sleep_ms(500);      \n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#configuracion-del-adc","title":"Configuraci\u00f3n del ADC","text":"<pre><code>\nadc.setup()     // Iicializa el ADC\nadc.read(0)     // Escoge el pin denl canal analogico\n\n</code></pre> <p>Ejemplo de prender y apagar leds dependiendo del valor del ADC:</p> <pre><code>\nunsigned int adc_result;  // Declaraci\u00f3n de variable para almacenar el valor del ADC\n\nfor {\n\n    adc_result = adc.read(0) ; // Almacena el valor del ADC\n\n    if ( adc_result &gt;= 1020 ){\n\n        pin.high(pin.b0);\n        pin.high(pin.b1);\n        pin.high(pin.b2);           \n    }\n\n    else if ( adc_result &gt;= 820 ){\n\n        pin.high(pin.b0);\n        pin.high(pin.b1);\n        pin.low(pin.b2);\n    }\n\n    else if ( adc_result &gt;= 620 ){\n\n        pin.high(pin.b0);\n        pin.low(pin.b1);\n        pin.low(pin.b2);   \n    }\n\n    else {\n\n        pin.low(pin.b0);\n        pin.low(pin.b1);\n        pin.low(pin.b2);      \n    }\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#configuracion-del-pwm","title":"Configuraci\u00f3n del PWM","text":"<pre><code>\npwm.setup()     // Inicializa el pwm\npwm.write()     // Calcula el ciclo de trabajo \n\n</code></pre> <p>Ejemplo de variar la intensidad de un led:</p> <pre><code>\nfor {\n\n    adc = adc.read(0);  // Almacena el valor del ADC\n\n    pwm.write(adc);  // Realiza el calculo del Duty y lo guarda en CCP2\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#configuracion-del-uart-transmision","title":"Configuraci\u00f3n del UART Transmisi\u00f3n","text":"<pre><code>\nuart.setup()     // Inicializa la comunicaci\u00f3n serial\n\n</code></pre> <p>Ejemplo enviar un caracter y visualizarlo en un mensaje:</p> <pre><code>\nfor {\n\n    uart.write(0x33);\n    time.sleep_ms(500);\n    uart.write(0x99);\n    time.sleep_ms(500);\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F873A/quickref/#configuracion-del-uart-recepcion","title":"Configuraci\u00f3n del UART Recepci\u00f3n","text":"<pre><code>\nuart.setup()     // Inicializa la comunicaci\u00f3n serial\n\n</code></pre> <p>Ejemplo prender y apagar un el puerto del micro enviando un caracteres desde el PC:</p> <pre><code>\nport.setup(port.b, 0b00000000);\nport.write(port.b, 0b00000000);\npin.setup(pin.c7, pin.input);\nuart.setup();\n\nfor {\n\n    port.read(port.b) = uart.read();\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/","title":"Guia R\u00e1pida para PIC16F886","text":""},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#referencia-del-pic16-utilizado-de-la-marca-microchip","title":"Referencia del PIC16 utilizado de la marca MICROCHIP","text":"<ul> <li>PIC16F886  </li> </ul> <p>NOTA: Este microcontrolador PIC16F cuenta con salidas digitales, entradas digitales, ADC, PWM y comunicaci\u00f3n serial.</p>"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#nombres-de-los-pines","title":"Nombres de los Pines","text":"<p>Los nombres de los pines se nombran con una letra que indica el puerto y un n\u00famero que indica el pin. Por ejemplo <code>a6</code> indica el pin 6 del puerto A. Todos los nombres en Aixt estan escritos en min\u00fasculas, para seguir V variable naming rules..</p>"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#nombres-de-los-pines-del-pic16f886","title":"Nombres de los pines del PIC16F886","text":"Puerto 0 1 2 3 4 5 6 7 A a0 a1 a2 a3 a4 a5 - - B b0 b1 b2 b3 b4 b5 b6 b7 C c0 c1 c2 c3 c4 c5 c6 c7 <p>En las familias de microcontroladores del PIC16, los registros del puerto se dividen en: </p> <ul> <li><code>TRIS</code> Para configurar cada pin del puerto</li> <li><code>PORT</code> Para gestionar los pines como entradas o salidas</li> </ul> <p>Luego, para facilitar la implementaci\u00f3n (y no generar c\u00f3digo inncesario) de este port Aixt, el nombre de cada pin difiere de su configuraci\u00f3n, entrada y salida como en el siguiente ejemplo: </p> <ul> <li><code>b5_s</code> Nombre del bit para configurar el <code>b5</code> pin como entrada o salida </li> <li><code>b5</code>   Nombre del bit para leer el pin como entrada o salida <code>b5</code></li> </ul>"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#componentes-integrados","title":"Componentes Integrados","text":"<ul> <li>Cuenta con 11 pines analogicos que se encuentran distribuidas en el puerto A.</li> </ul> Puerto 0 1 2 3 4 5 6 7 A AN0 AN1 AN2 AN3 - AN4 - - B AN12 AN10 AN8 AN9 AN11 AN13 - - C - - - - - - - - <ul> <li>Cuenta con dos pines para la modulacion del PWM.</li> </ul> Puerto 0 1 2 3 4 5 6 7 A - - - - - - - - B - - - - - - - - C - c1 c2 - - - - - <ul> <li>Cuenta con dos pines para la cominicaci\u00f3n serial.   </li> </ul> Puerto 0 1 2 3 4 5 6 7 A - - - - - - - - B - - - - - - - - C - - - - - - c6 c7"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#funciones-soportadas","title":"Funciones soportadas","text":"<p>Las funciones que contiene la API entradas o salidas digitales, conversor analogico a digital, modulaci\u00f3n pwm y comunicaci\u00f3n serial.</p> name description <code>pin.setup(pin_name, mode)</code> Configura <code>PIN_NAME</code> en <code>PIN_MODE</code> <code>pin.high(PIN_NAME)</code> Encender <code>PIN_NAME</code> <code>pin.low(PIN_NAME)</code> Apagar <code>PIN_NAME</code> <code>pin.write(PIN_NAME,VAL)</code> Escribe <code>VAL</code> en <code>PIN_NAME</code> <code>pin.read(PIN_NAME)</code> lee <code>PIN_NAME</code> <code>pin.digital(PIN)</code> Configura I/0 digitales <code>PIN_NAME</code> <code>pin (PIN)</code> Configura <code>PIN_OUTPUT</code> o <code>PIN_INPUT</code> <code>port</code> Inicializa <code>port</code> <code>port.read(PORT_NAME)</code> Lee <code>PORT_NAME</code> <code>port.setup(PORT_NAME, VALUE)</code> Configura <code>PORT_NAME</code> asigna valor <code>VALUE</code> <code>port.write(PORT_NAME, VALUE)</code> Escribe <code>PORT_NAME</code> en <code>VALUE</code> <code>adc.setup()</code> Configura el <code>adc</code> <code>adc.read(channel)</code> Configura el canal <code>channel</code> del <code>adc</code> <code>adc</code> Inicializa <code>adc</code> <code>pwm.setup()</code> Configura el resgitro <code>pwm</code> <code>pwm.write(duty)</code> Calcula el <code>duty</code> del <code>pwm</code> <code>pwm</code> Inicializa <code>pwm</code> <code>uart.setup()</code> Configura el <code>uart</code> <code>uart.read()</code> Lee los datos del <code>uart</code> <code>uart.write()</code> Escribe los datos del <code>uart</code> <code>uart</code> Inicializa el <code>uart</code> <code>time.sleep(time)</code> Retardo en <code>seg</code> <code>time.sleep_us(time)</code> Retardo en <code>microseg</code> <code>time.sleep_ms(time)</code> Retardo en <code>miliseg</code> <code>time</code> Inicializa el <code>time</code>"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#ejemplos-de-las-diferentes-funciones-de-la-api-en-lenguaje-_aixt_v","title":"Ejemplos de las diferentes funciones de la API en lenguaje _Aixt_v","text":""},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#tiempo","title":"Tiempo","text":"<pre><code>\ntime.sleep(5)   // Tiempo de 5 segundos\ntime.sleep_us(10)   // Tiempo de 10 microsegundos\ntime.sleep_ms(500)  // Tiempo de 500 milisegundos\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#configuracion-de-pines","title":"Configuraci\u00f3n de pines","text":"<pre><code>\npin.setup(pin.a5, pin.output)      // Funci\u00f3n para configurar el pin como salida \npin.setup(pin.b7, pin.output)      // Funci\u00f3n para configurar el pin como salida\npin.setup(pin.a0, pin.input)    // Funci\u00f3n para configurar el pin como entrada\npin.setup(pin.c4, pin.input)    // Funci\u00f3n para configurar el pin como entrada\n\npin.high(pin.a5)    // Funci\u00f3n para encender el pin           \npin.low(pin.a5)     // Funci\u00f3n para apagar el pin\n\npin.write(pin.a2, 0)  // Funci\u00f3n sobre escribir el pin\npin.write(pin.a2, 1)  // Funci\u00f3n sobre escribir el pin\n\npin.read(pin.b4)      // Funci\u00f3n para leer el pin\npin.read(pin.c7)      // Funci\u00f3n para leer el pin\n\n</code></pre> <p>Ejemplo de prender y apagar un led:</p> <pre><code>\nfor {\n\n    pin.high(pin.c7);\n    sleep_us(500);\n    pin.low(pin.c7);\n    sleep_us(500);\n\n}\n\n</code></pre> <p>Ejemplo de prender y apagar un led con una entrada digital:</p> <pre><code>\npin.digital();\n\nfor {\n\n    if(b4 == 1){        // Condici\u00f3n si encuentra un 1 en el c2\n\n        pin.high(pin.a4);\n        pin.high(pin.a5);\n    }\n\n    else if(b5 == 1){   // Condici\u00f3n si encuentra un 1 en el c4\n\n        pin.low(pin.a4);\n        pin.low(pin.a5);\n    }\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#configuracion-del-port","title":"Configuraci\u00f3n del port","text":"<pre><code>\nport.setup(port.b, ob00000000)      // Funci\u00f3n para configurar el puerto como salida \n\n</code></pre> <p>Ejemplo de prender y apagar un puerto del microcontrolador:</p> <pre><code>\nfor {\n\n    port.write(port.b,0b01010101);\n    sleep_ms(500);\n    port.write(port.b,0b10101010);\n    sleep_ms(500);      \n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#configuracion-del-adc","title":"Configuraci\u00f3n del ADC","text":"<pre><code>\nadc.setup()     // Iicializa el ADC\nadc.read(0)     // Escoge el pin denl canal analogico\n\n</code></pre> <p>Ejemplo de prender y apagar leds dependiendo del valor del ADC:</p> <pre><code>\nunsigned int adc_result;  // Declaraci\u00f3n de variable para almacenar el valor del ADC\n\nfor {\n\n    adc_result = adc.read(0) ; // Almacena el valor del ADC\n\n    if ( adc_result &gt;= 1020 ){\n\n        pin.high(pin.b0);\n        pin.high(pin.b1);\n        pin.high(pin.b2);           \n    }\n\n    else if ( adc_result &gt;= 820 ){\n\n        pin.high(pin.b0);\n        pin.high(pin.b1);\n        pin.low(pin.b2);\n    }\n\n    else if ( adc_result &gt;= 620 ){\n\n        pin.high(pin.b0);\n        pin.low(pin.b1);\n        pin.low(pin.b2);   \n    }\n\n    else {\n\n        pin.low(pin.b0);\n        pin.low(pin.b1);\n        pin.low(pin.b2);      \n    }\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#configuracion-del-pwm","title":"Configuraci\u00f3n del PWM","text":"<pre><code>\npwm.setup()     // Inicializa el pwm\npwm.write()     // Calcula el ciclo de trabajo \n\n</code></pre> <p>Ejemplo de variar la intensidad de un led:</p> <pre><code>\nfor {\n\n    adc = adc.read(0);  // Almacena el valor del ADC\n\n    pwm.write(adc);  // Realiza el calculo del Duty y lo guarda en CCP2\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#configuracion-del-uart-transmision","title":"Configuraci\u00f3n del UART Transmisi\u00f3n","text":"<pre><code>\nuart.setup()     // Inicializa la comunicaci\u00f3n serial\n\n</code></pre> <p>Ejemplo enviar un caracter y visualizarlo en un mensaje:</p> <pre><code>\nfor {\n\n    uart.write(0x33);\n    time.sleep_ms(500);\n    uart.write(0x99);\n    time.sleep_ms(500);\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F886/quiickref/#configuracion-del-uart-recepcion","title":"Configuraci\u00f3n del UART Recepci\u00f3n","text":"<pre><code>\nuart.setup()     // Inicializa la comunicaci\u00f3n serial\n\n</code></pre> <p>Ejemplo prender y apagar un el puerto del micro enviando un caracteres desde el PC:</p> <pre><code>\nport.setup(port.b, 0b00000000);\nport.write(port.b, 0b00000000);\npin.setup(pin.c7, pin.input);\nuart.setup();\n\nfor {\n\n    port.read(port.b) = uart.read();\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/","title":"Quick reference for the PIC16F8x family","text":"<p>Quick reference for the Microchip PIC16F8x devices: - PIC16F83 - PIC16F84 - PIC16F84A</p> <p>NOTE: This PIC16F8x microcontrollers only has digital outputs and digital inputs</p>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#general-mu-c-control","title":"General $\\mu C$ control","text":"<pre><code>// by default the CPU oscillation frequency is 10Mhz\n@[as_macro] const cpu_freq = 4_000_000  // change it to 4Mhz\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#delay","title":"Delay","text":"<p>Use the <code>time</code> module:</p> <pre><code>import time\n\ntime.sleep(2)            // sleep for 2 seconds\ntime.sleep_ms(50)        // sleep for 50 milliseconds\ntime.sleep_us(100)       // sleep for 100 microseconds\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#functions","title":"Functions","text":"name description <code>time.sleep(time)</code> Delay in seconds <code>time.sleep_us(time)</code> Delay in microseconds <code>time.sleep_ms(time)</code> Delay in milliseconds"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#pins","title":"Pins","text":"<p>Use the <code>pin</code> module:</p> <pre><code>import pin\n\npin.setup(pin.a1, pin.input)\npin.high(pin.b0)\npin.low(pin.a3)\npin.toggle(pin.b7)\npin.write(pin.b2, pin.read(pin.a1)) // pin echo\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#functions_1","title":"Functions","text":"name description <code>pin.setup(pin, mode)</code> Configure <code>pin</code> as <code>mode</code> <code>pin.high(pin)</code> Turn On <code>pin</code> <code>pin.low(pin)</code> Turn Off <code>pin</code> <code>pin.toggle(pin)</code> Toggle the state of <code>pin</code> <code>pin.write(pin, value)</code> Write <code>value</code> in <code>pin</code> <code>pin.read(pin)</code> Return the state of <code>pin</code>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#digital-pin-names","title":"Digital pin names","text":"<p>The pin names are named with a letter indicating the port and a number indicating the pin. For example, <code>a6</code> indicates pin 6 of port A. All names in Aixt are written in lowercase, to follow V variable naming rules..</p>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#pin-names-for-pic16f8x","title":"Pin names for PIC16F8x","text":"Port 0 1 2 3 4 5 6 7 A <code>a0</code> <code>a1</code> <code>a2</code> <code>a3</code> <code>a4</code> ----- ----- ----- B <code>b0</code> <code>b1</code> <code>b2</code> <code>b3</code> <code>b4</code> <code>b5</code> <code>b6</code> <code>b7</code>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#pin-ports","title":"Pin ports","text":"<p>Use the <code>port</code> module:</p> <pre><code>import port\n\nport.setup(port.b, port.all_outputs)\nport.setup(port.a, 0x00111111)  // port A bit 7 and 6 as outputs, the rest as inputs\n\nval := port.read(port.a)\nport.write(port.b, val) // port echo\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#functions_2","title":"Functions","text":"name description <code>port.setup(port, mode)</code> Configure <code>port</code> as <code>mode</code> <code>port.read(port)</code> Return the value of <code>port</code> <code>port.write(port, value)</code> Write <code>value</code> to <code>port</code>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#digital-port-names","title":"Digital port names","text":"<p>The port names are named with a letter indicating the port. All names in Aixt are written in lowercase, to follow V variable naming rules..</p>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#pin-names-for-pic16f8x_1","title":"Pin names for PIC16F8x","text":"Port Aixt name A <code>a</code> B <code>b</code>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#timer-0","title":"Timer 0","text":"<p>Use the <code>timer0</code> module:</p> <pre><code>import timer0\n\n@[as_macro] const cpu_freq = 4_000_000  // 4Mhz\n\ntimer0.setup(10_000)    // setup a time of 10ms\n.\n.\n.\nt1 := timer0.read()\ntimer0.restart()\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#functions_3","title":"Functions","text":"name description <code>timer0.setup(period)</code> Configure Timer0's <code>period</code> <code>timer0.read()</code> Return the value of Timer0 <code>timer0.restart()</code> Restart the Timer0 from its initial value <code>timer0.irq_enable()</code> Enable Timer0 overflow interrupt <code>timer0.irq_disable()</code> Disable Timer0 overflow interrupt"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#external-interrupt","title":"External Interrupt","text":"<p>Use the <code>ext</code> module:</p> <pre><code>import ext\n\next.setup(ext.falling)  // rising edge for external interrupt\next.irq_enable()        // enable the interrupt\n</code></pre>"},{"location":"repoFer/Microchip/PIC16/PIC16F8x/quickref/#functions_4","title":"Functions","text":"name description <code>ext.setup(edge)</code> Configure external interrupt <code>edge</code> <code>ext.irq_enable()</code> Enable external interrupt <code>ext.irq_disable()</code> Disable external interrupt"},{"location":"repoFer/Microchip/PIC18/PIC18F2550/quickref/","title":"Guia R\u00e1pida para PIC18F2550","text":""},{"location":"repoFer/Microchip/PIC18/PIC18F2550/quickref/#referencia-del-pic18-utilizado-de-la-marca-microchip","title":"Referencia del PIC18 utilizado de la marca MICROCHIP","text":"<ul> <li>PIC18F2550</li> </ul> <p>NOTA: Este microcontrolador PIC18F cuenta con salidas digitales, entradas digitales, ADC, PWM y comunicaci\u00f3n serial.</p>"},{"location":"repoFer/Microchip/PIC18/PIC18F2550/quickref/#nombres-de-los-pines","title":"Nombres de los Pines","text":"<p>Los nombres de los pines se nombran con una letra que indica el puerto y un n\u00famero que indica el pin. Por ejemplo <code>a3</code> indica el pin 3 del puerto A. Todos los nombres en Aixt estan escritos en min\u00fasculas, para seguir V variable naming rules..</p>"},{"location":"repoFer/Microchip/PIC18/PIC18F2550/quickref/#nombres-de-los-pines-del-pic18f2550","title":"Nombres de los pines del PIC18F2550","text":"<p>| Puerto | - | - | - | - | - | - | - | - |  | A  | a0| a1| a2| a3| a4| a5| a6| - | | B  | b0| b1| b2| b3| b4| b5| b6| b7| | C  | c0| c1| c2| - | c4| c5| c6| c7|</p> <p>En las familias de microcontroladores del PIC18F2550, los registros del puerto se dividen en: </p> <ul> <li><code>TRIS</code> Para configurar cada pin del puerto</li> <li><code>PORT</code> Lee los niveles en los pines del dispositivo </li> </ul> <p>Luego, para facilitar la implementaci\u00f3n (y no generar c\u00f3digo inncesario) de este port Aixt, el nombre de cada pin difiere de su configuraci\u00f3n, entrada y salida como en el siguiente ejemplo: </p> <ul> <li><code>b2_s</code>  Nombre del bit para configurar el <code>b2</code> pin como entrada o salida </li> <li><code>b2_i</code>  Nombre del bit para leer el pin como entrada <code>b2</code></li> <li><code>b2</code>    Nombre del bit para leer el pin como salida  <code>b2</code></li> </ul>"},{"location":"repoFer/Microchip/PIC18/PIC18F2550/quickref/#componentes-integrados","title":"Componentes Integrados","text":"<ul> <li>Cuenta con seis pines analogicos que se encuentran distribuidas en el puerto A.</li> </ul> Puerto 0 1 2 3 4 5 6 7 A AN0 AN1 AN2 AN3 - AN4 - - B AN12 AN10 AN8 AN9 AN11 - - - C - - - - - - - - <ul> <li>Cuenta con dos pines para la modulacion del PWM.</li> </ul> Puerto 0 1 2 3 4 5 6 7 A - - - - - - - - B - - - b3 - - - - C - c1 c2 - - - - - <ul> <li> <p>Note 1: RB3 es el pin alternativo para el registro CCP2</p> </li> <li> <p>Cuenta con dos pines para la cominicaci\u00f3n serial.   </p> </li> </ul> Puerto 0 1 2 3 4 5 6 7 A - - - - - - - - B - - - - - - - - C - - - - - - c6 c7"},{"location":"repoFer/Microchip/PIC18/PIC18F2550/quickref/#funciones-soportadas","title":"Funciones soportadas","text":"<p>Las funciones que contiene la API entradas o salidas digitales, conversor analogico a digital, modulaci\u00f3n pwm y comunicaci\u00f3n serial.</p> name description <code>pin.high(pin)</code> Modo alto <code>pin</code> <code>pin.low(pin)</code> Modo bajo <code>pin</code> <code>pin.write(pin, val)</code> Escribe <code>val</code> en <code>pin</code> <code>pin.read(pin)</code> Lee <code>pin</code> <code>pin.setup(pin, mode)</code> Configura pines I/O     <code>pin</code> <code>port.setup(port, mode)</code> Configura puertos I/O   <code>pin</code> <code>port.write(port, val)</code> Escribe <code>val</code> en <code>port</code> <code>port.read(port)</code> Lee <code>port</code> <code>adc.setup()</code> Configura el <code>adc</code> <code>adc.read(channel)</code> Configura el canal <code>channel</code> del <code>adc</code> <code>adc.reading()</code> Alamacena el valor del <code>adc</code> <code>pwm.setup(pin1, pin2)</code> Configura el resgitro <code>pin1</code> y la salida en <code>pin2</code> <code>pwm.write(duty, pin)</code> Calcula el <code>duty</code> del <code>pwm</code> y lo alamcena en <code>pin</code> <code>uart.setup()</code> Configura el <code>uart</code> <code>uart.write()</code> Configura el <code>TX</code> <code>uart.read()</code> Configura el <code>RX</code> <code>sleep(time)</code> Retardo en <code>seg</code> <code>sleep_us(time)</code> Retardo en <code>microseg</code> <code>sleep_ms(time)</code> Retardo en <code>miliseg</code>"},{"location":"repoFer/Microchip/PIC18/PIC18F2550/quickref/#configuracion-de-pines","title":"Configuraci\u00f3n de pines","text":"<pre><code>pin.setup(pin.b3, pin.output)      // Funci\u00f3n para configurar el pin como salida \npin.setup(pin.a2, pin.output)      // Funci\u00f3n para configurar el pin como salida\npin.setup(pin.b2, pin.input)    // Funci\u00f3n para configurar el pin como entrada\npin.setup(pin.a1, pin.input)    // Funci\u00f3n para configurar el pin como entrada\n\npin.high(pin.b3)    // Funci\u00f3n para encender el pin           \npin.low(pin.b3)     // Funci\u00f3n para apagar el pin\n\npin.write(pin.a4, 0)  // Funci\u00f3n sobre escribir el pin\npin.write(pin.a4, 1)  // Funci\u00f3n sobre escribir el pin\n\npin.read(pin.c4)      // Funci\u00f3n para leer el pin\npin.read(pin.b0)      // Funci\u00f3n para leer el pin\n</code></pre> <p>Ejemplo de prender y apagar un led:</p> <pre><code>\nwhile (1) {\n    pin.high(pin.b4);\n    time.sleep_us(700);\n    pin.low(pin.b4);\n    time.sleep_us(700);\n}\n</code></pre> <p>Ejemplo de prender y apagar un led con una entrada digital:</p> <pre><code>\nwhile(1){\n\n    if(a4 == 0){        // Condici\u00f3n si encuentra un 0 en el a4\n\n        pin.high(pin.c0);\n        pin.high(pin.c2);\n    }\n\n    else if(b2 == 1){   // Condici\u00f3n si encuentra un 1 en el b2\n\n        pin.low(pin.a1);\n        pin.low(pin.c2);\n    }\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC18/PIC18F2550/quickref/#configuracion-del-adc","title":"Configuraci\u00f3n del ADC","text":"<pre><code>adc.setup()     // Iicializa el ADC\nadc.read(0)     // Escoge el pin denl canal analogico\nadc.reading();  // Almacena el valor del ADC en una funci\u00f3n\n\n</code></pre> <p>Ejemplo de prender y apagar leds dependiendo del valor del ADC:</p> <pre><code>unsigned int adc_RTA;  // Declaraci\u00f3n de variable para almacenar el valor del ADC\n\nwhile(1){\n\n    adc_RTA = adc.reading(); // Almacena el valor del ADC\n\n    if ( adc_RTA &gt;= 1000 ){\n\n        pin.high(pin.C4);\n        pin.high(pin.C1);\n        pin.high(pin.C2);           \n    }\n\n    else if ( adc_RTA &gt;= 600 ){\n\n        pin.high(pin.b5);\n        pin.high(pin.b1);\n        pin.low(pin.b3);\n    }\n\n    else if ( adc_RTA &gt;= 340 ){\n\n        pin.high(pin.a0);\n        pin.low(pin.a1);\n        pin.low(pin.a2);   \n    }\n\n    else {\n\n        pin.low(pin.c7);\n        pin.low(pin.c6);\n        pin.low(pin.c5);      \n    }\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC18/PIC18F2550/quickref/#configuracion-del-pwm","title":"Configuraci\u00f3n del PWM","text":"<pre><code>pwm.setup()     // Inicializa el pwm\npwm.write()     // Calcula el ciclo de trabajo \n\n</code></pre> <p>Ejemplo de variar la intensidad de un led:</p> <pre><code> while(1){\n\n        adc := adc.read(3)  // Almacena el valor del ADC\n        pwm.write(adc)  // Calcula el ciclo de trabajo y lo establece en el m\u00f3dulo PWM CCP1\n\n    }\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC18/PIC18F2550/quickref/#configuracion-del-uart-transmision","title":"Configuraci\u00f3n del UART Transmisi\u00f3n","text":"<pre><code>\n       //CONFIG DE LOS PINES\n    pin.setup(pin.c6,output)   //RC6 = TX\n\n       //Inicializamos la comunicaci\u00f3n serial\n    uart.setup()\n\n    for {\n         uart.write(0x33)\n         time.sleep_ms(500)\n         uart.write(0x99)\n         time.sleep_ms(500)\n     }\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC18/PIC18F2550/quickref/#configuracion-del-uart-recepcion","title":"Configuraci\u00f3n del UART Recepcion","text":"<pre><code>\n    port.setup(port.b, pin.port.output)\n\n    // LIMPIAMOS EL PUERTO B\n\n    port.write(port.b, pin.port.output)\n\n\n   // CONFIGURAMOS EL C7 PARA LA RECEPCI\u00d3N DE DATOS\n    pin.setup(pin.c7,input)\n\n   // INICIALIZAMOS LA COMUNICACION SERIAL EN 9600 BAUDIOS\n    uart.setup()             \n\n     for {\n         port.write(port.b, uart.read())\n     }\n</code></pre>"},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/","title":"Guia R\u00e1pida para PIC18F452","text":""},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/#referencia-del-pic18-utilizado-de-la-marca-microchip","title":"Referencia del PIC18 utilizado de la marca MICROCHIP","text":"<ul> <li>PIC18F452</li> </ul> <p>NOTA: Este microcontrolador PIC18F cuenta con salidas digitales, entradas digitales, ADC, PWM y comunicaci\u00f3n serial.</p>"},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/#nombres-de-los-pines","title":"Nombres de los Pines","text":"<p>Los nombres de los pines se nombran con una letra que indica el puerto y un n\u00famero que indica el pin. Por ejemplo <code>a3</code> indica el pin 3 del puerto A. Todos los nombres en Aixt estan escritos en min\u00fasculas, para seguir V variable naming rules..</p>"},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/#nombres-de-los-pines-del-pic18f452","title":"Nombres de los pines del PIC18F452","text":"<p>| Puerto | - | - | - | - | - | - | - | - | | A  | a0| a1| a2| a3| a4| a5| - | - | | B  | b0| b1| b2| b3| b4| b5| b6| b7| | C  | c0| c1| c2| c3| c4| c5| c6| c7| | D  | d0| d1| d2| d3| d4| d5| d6| d7|</p> <p>En las familias de microcontroladores del PIC18F452, los registros del puerto se dividen en: </p> <ul> <li><code>TRIS</code> Para configurar cada pin del puerto</li> <li><code>PORT</code> Lee los niveles en los pines del dispositivo </li> </ul> <p>Luego, para facilitar la implementaci\u00f3n (y no generar c\u00f3digo inncesario) de este port Aixt, el nombre de cada pin difiere de su configuraci\u00f3n, entrada y salida como en el siguiente ejemplo: </p> <ul> <li><code>b2_s</code> Nombre del bit para configurar el <code>b2</code> pin como entrada o salida </li> <li><code>b2_i</code>  Nombre del bit para leer el pin como entrada <code>b2</code></li> <li><code>b2</code>    Nombre del bit para leer el pin como salida  <code>b2</code></li> </ul>"},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/#componentes-integrados","title":"Componentes Integrados","text":"<ul> <li>Cuenta con seis pines analogicos que se encuentran distribuidas en el puerto A.</li> </ul> Puerto 0 1 2 3 4 5 6 7 A AN0 AN1 AN2 AN3 - AN4 - - B - - - - - - - - C - - - - - - - - D - - - - - - - - E AN5 AN6 AN7 - - - - - <ul> <li>Cuenta con dos pines para la modulacion del PWM.</li> </ul> Puerto 0 1 2 3 4 5 6 7 A - - - - - - - - B - - - - - - - - C - c1 c2 - - - - - D - - - - - - - - E - - - - - - - - <ul> <li>Cuenta con dos pines para la cominicaci\u00f3n serial.   </li> </ul> Puerto 0 1 2 3 4 5 6 7 A - - - - - - - - B - - - - - - - - C - - - - - - c6 c7 D - - - - - - - - E - - - - - - - -"},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/#funciones-soportadas","title":"Funciones soportadas","text":"<p>Las funciones que contiene la API entradas o salidas digitales, conversor analogico a digital, modulaci\u00f3n pwm y comunicaci\u00f3n serial.</p> name description <code>pin.high(pin)</code> Modo alto <code>pin</code> <code>pin.low(pin)</code> Modo bajo <code>pin</code> <code>pin.write(pin, val)</code> Escribe <code>val</code> en <code>pin</code> <code>pin.read(pin)</code> Lee <code>pin</code> <code>pin.setup(pin, mode)</code> Configura pines I/O     <code>pin</code> <code>port.setup(port, mode)</code> Configura puertos I/O   <code>pin</code> <code>port.write(port, val)</code> Escribe <code>val</code> en <code>port</code> <code>port.read(port)</code> Lee <code>port</code> <code>adc.setup()</code> Configura el <code>adc</code> <code>adc.read(channel)</code> Configura el canal <code>channel</code> del <code>adc</code> <code>adc.reading()</code> Almacena el valor del <code>adc</code> <code>pwm.setup(pin1, pin2)</code> Configura el registro <code>pin1</code> y la salida en <code>pin2</code> <code>pwm.write(duty, pin)</code> Calcula el <code>duty</code> del <code>pwm</code> y lo alamcena en <code>pin</code> <code>uart.setup()</code> Configura el <code>uart</code> <code>uart.write()</code> Configura el <code>TX</code> <code>uart.read()</code> Configura el <code>RX</code> <code>time.sleep(TIME)</code> Retardo en <code>seg</code> <code>time.sleep_us(TIME)</code> Retardo en <code>microseg</code> <code>time.sleep_ms(TIME)</code> Retardo en <code>miliseg</code>"},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/#configuracion-de-pines","title":"Configuraci\u00f3n de pines","text":"<pre><code>pin.setup(pin.d3, pin.output)      // Funci\u00f3n para configurar el pin como salida \npin.setup(pin.a2, pin.output)      // Funci\u00f3n para configurar el pin como salida\npin.setup(pin.b5, pin.input)    // Funci\u00f3n para configurar el pin como entrada\npin.setup(pin.d1, pin.input)    // Funci\u00f3n para configurar el pin como entrada\n\npin.high(pin.b3)    // Funci\u00f3n para encender el pin           \npin.low(pin.b3)     // Funci\u00f3n para apagar el pin\n\npin.write(pin.d1, 0)  // Funci\u00f3n sobre escribir el pin\npin.write(pin.d1, 1)  // Funci\u00f3n sobre escribir el pin\n\npin.read(pin.a4)      // Funci\u00f3n para leer el pin\npin.read(pin.b3)      // Funci\u00f3n para leer el pin\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/#configuracion-de-puertos","title":"Configuraci\u00f3n de puertos","text":"<pre><code>\nport.setup(port.d3, pin.output)      // Funci\u00f3n para configurar el pin como salida \nport.setup(port.b5, pin.input)    // Funci\u00f3n para configurar el pin como entrada\n\nport.write(port.d1, 0b01010101)  // Funci\u00f3n sobre escribir el pin\nport.write(port.d1, 0x00)  // Funci\u00f3n sobre escribir el pin\n\nport.read(port.a4)      // Funci\u00f3n para leer el pin\nport.read(port.b3)      // Funci\u00f3n para leer el pin\n\n</code></pre> <p>Ejemplo de prender y apagar un led:</p> <pre><code>\nfor {\n    pin.high(pin.d4)\n    time.sleep_ms(500)\n    pin.low(pin.d4)\n    time.sleep_ms(500)\n}\n</code></pre> <p>Ejemplo de prender y apagar un led con una entrada digital:</p> <pre><code>\nfor {\n\n    if(d4 == 0){        // Condici\u00f3n si encuentra un 0 en el d4\n\n        pin.high(pin.c3)\n        pin.high(pin.c5)\n    }\n\n    else if(d2 == 1){   // Condici\u00f3n si encuentra un 1 en el d2\n\n        pin.low(pin.a4)\n        pin.low(pin.a2)\n    }\n\n}\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/#configuracion-del-adc","title":"Configuraci\u00f3n del ADC","text":"<pre><code>\n    adc.setup()\n\n// CONFIGURAMOS EL PUERTO B COMO SALIDA\n\n    port.setup(port.b, pin.port.output)\n\n    // CONFIGURAMOS EL PUERTO C COMO SALIDA\n\n    port.setup(port.c, pin.port.output)\n\n    // LIMPIAMOS EL PUERTO B\n\n    port.write(port.b, 0x00)\n\n    // LIMPIAMOS EL PUERTO c\n\n    port.write(port.c, 0x00)\n\n    for\n    {\n\n        adc.read(0)\n        valor := adc.reading()\n        port.write(port.b, valor &amp; 0xFF)                   // Muestra el dato de la parte baja en el puerto B\n        port.write(port.c, (valor&gt;&gt;8) &amp; 0x03 )                 // Muestra el dato de la parte alta en el puerto C\n        time.sleep_ms(10)\n    }\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/#configuracion-del-pwm","title":"Configuraci\u00f3n del PWM","text":"<pre><code>pwm.setup(1, 2)     // Inicializa el pwm\npwm.write(val, 1)     // Calcula el ciclo de trabajo \n\n</code></pre> <p>Ejemplo de variar la intensidad de un led:</p> <pre><code> for {    \n        valor_adc := adc.read(0)  // Almacena el valor del ADC\n        pwm.write(valor_adc,1)  // Calcula el ciclo de trabajo y lo establece en el m\u00f3dulo PWM CCP1        \n    }\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/#configuracion-del-uart-transmision","title":"Configuraci\u00f3n del UART Transmisi\u00f3n","text":"<pre><code>\n       //CONFIG DE LOS PINES\n    pin.setup(pin.c6,output)   //RC6 = TX\n\n       //Inicializamos la comunicaci\u00f3n serial\n    uart.setup()\n\n    for {\n         uart.write(0x33)\n         time.sleep_ms(500)\n         uart.write(0x99)\n         time.sleep_ms(500)\n     }\n\n</code></pre>"},{"location":"repoFer/Microchip/PIC18/PIC18F452/quickref/#configuracion-del-uart-recepcion","title":"Configuraci\u00f3n del UART Recepcion","text":"<pre><code>\n    port.setup(port.b, pin.port.output)\n\n    // LIMPIAMOS EL PUERTO B\n\n    port.write(port.b, pin.port.output)\n\n\n   // CONFIGURAMOS EL C7 PARA LA RECEPCI\u00d3N DE DATOS\n    pin.setup(pin.c7,input)\n\n   // INICIALIZAMOS LA COMUNICACION SERIAL EN 9600 BAUDIOS\n    uart.setup()             \n\n     for {\n         port.write(port.b, uart.read())\n     }\n\n\n\n\n\n</code></pre>"},{"location":"repoFer/NXT/quickref/","title":"Quick reference for Mindstorms NXT brick","text":""},{"location":"repoFer/NXT/quickref/#transpiled-to-nxc-language","title":"(transpiled to NXC language)","text":"<p>This Aixt port works as an NXC language wrapper. Most of the name functions keep the same function names, but using snake_case instead of CamelCase, but some of them are totally change. For instance this Aixt code:</p> <pre><code>forward(motor_a, 75)    \nforward(motor_c, 75)\ntime.sleep(4000)          \nreverse(motors_ac, 75)  \ntime.sleep(4000)\noff(motors_ac)\n</code></pre> <p>will be transpiled to:</p> <pre><code>task main()\n{\n    OnFwd(OUT_A, 75);\n    OnFwd(OUT_C, 75);\n    Wait(4000);\n    OnRev(OUT_AC, 75);\n    Wait(4000);\n    Off(OUT_AC);\n}\n</code></pre>"},{"location":"repoFer/NXT/quickref/#multitasking","title":"Multitasking","text":"<p>The Aixt port for NXC language suports tasks by using attributes and special variable types. In this case the special type <code>mutex</code> is used for implementing mutex variables, and the attribute <code>[task]</code> for implementing task functions. For instance, the follow code: </p> <pre><code>@[task] fn move_square() {\n    for {\n        acquire(move_mutex)\n        forward(motors_ac, 75)\n        sleep(1000)\n        reverse(motor_c, 75)\n        sleep(500)\n        release(move_mutex)\n    }\n}\n\n@[task] fn check_sensors() {\n    for {\n        if sensor_1 == 1 {\n            acquire(move_mutex)\n            reverse(motors_ac, 75)\n            sleep(500)\n            forward(motor_a, 75)\n            sleep(500)\n            release(move_mutex)\n        }\n    }\n}\n\nmove_mutex := mutex('') //initialization value is necesary but will be ingnored\n\ntask.priority(move_square, check_sensors)\nset_sensor_touch(in_1)\n</code></pre> <p>will be transpiled to:</p> <pre><code>mutex move_mutex;\n\ntask move_square()\n{\n    while (true)\n    {\n        Acquire(move_mutex);\n        OnFwd(OUT_AC, 75); \n        Wait(1000);\n        OnRev(OUT_C, 75); \n        Wait(500);\n        Release(move_mutex);\n    }\n}\n\ntask check_sensors()\n{\n    while (true)\n    {\n        if (SENSOR_1 == 1)\n        {\n            Acquire(move_mutex);\n            OnRev(OUT_AC, 75); \n            Wait(500);\n            OnFwd(OUT_A, 75); \n            Wait(500);\n            Release(move_mutex);\n        }\n    }\n}\n\ntask main()\n{\n    Precedes(move_square, check_sensors);\n    SetSensorTouch(IN_1);\n}\n</code></pre> <p>The complete list of the equivalences is in NXT.toml file in the dictionary named <code>aliases</code>.</p> <p>The NXC port of Aixt can be used in script mode (without main function). In that case the mutex variables have to be \"declared\" after task functions definition, as shown in the previous example.</p>"},{"location":"repoFer/NXT/quickref/#installing","title":"Installing","text":"<p><code>Aixt</code> project includes the <code>nbc</code> compiler for both Windows and Linux, but you have to install manually the USB drivers.</p>"},{"location":"repoFer/NXT/quickref/#for-windows","title":"for Windows","text":"<p>Download the NXT software from (https://education.lego.com/en-us/downloads/retiredproducts/nxt/software)[https://education.lego.com/en-us/downloads/retiredproducts/nxt/software], and install only the drivers.</p>"},{"location":"repoFer/NXT/quickref/#for-linux","title":"for Linux","text":"<p>Install the last version of <code>libusb-dev</code> package acording to your distribution. For instance in a Debian-based distribution you can type in a terminal:</p> <pre><code>apt-get install libusb-1.0-0-dev\n</code></pre> <p>or</p> <pre><code>apt-get install libusb-dev\n</code></pre>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/","title":"Quick reference for the Arduino Nano board","text":""},{"location":"repoFer/Raspberry-Pi/pico/quickref/#delay","title":"Delay","text":"<p>Use the <code>time</code> module:</p> <pre><code>import time\n\ntime.sleep(2)            // sleep for 2 seconds\ntime.sleep_ms(50)        // sleep for 50 milliseconds\ntime.sleep_us(100)       // sleep for 100 microseconds\n</code></pre>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#functions","title":"Functions","text":"name description <code>time.sleep(time)</code> Delay in seconds <code>time.sleep_us(time)</code> Delay in microseconds <code>time.sleep_ms(time)</code> Delay in milliseconds"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#internal-leds","title":"Internal LEDs","text":"<p>The onboard LED is named <code>led_0</code> </p> <pre><code>import pin\n\npin.setup(led_0, pin.output)\npin.high(led_0)\n</code></pre>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#pins","title":"Pins","text":"<p>Use the <code>pin</code> module:</p> <pre><code>import pin\n\npin.setup(pin.d0, pin.input)\npin.high(pin.d13)\npin.low(pin.d3)\npin.write(pin.d8, pin.read(pin.d0)) // pin echo\n</code></pre>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#functions_1","title":"Functions","text":"name description <code>pin.setup(pin, mode)</code> Configure <code>pin</code> as <code>mode</code> <code>pin.high(pin)</code> Turn On <code>pin</code> <code>pin.low(pin)</code> Turn Off <code>pin</code> <code>pin.write(pin, value)</code> Write <code>value</code> in <code>pin</code> <code>pin.read(pin)</code> Return the state of <code>pin</code>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#digital-pin-names","title":"Digital pin names","text":"<p>The digital pin names are named from <code>d0</code> to <code>d21</code>.</p>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#pwm-pulse-width-modulation","title":"PWM (Pulse Width Modulation)","text":"<p>Use the <code>pwm</code> module:</p> <pre><code>import pwm\n\npwm.write(pwm.pin.gp7, 40)       // set the duty cycle for gp7 pin\npwm.write(pwm.pin.gp8, 60)       // set the duty cycle for gp8 pin\n</code></pre>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#functions_2","title":"Functions","text":"name description <code>pwm.write(channel, value)</code> Write <code>value</code> in the PWM <code>channel</code>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#pwm-pin-names","title":"PWM pin names","text":"<p>All the digital pins are able to be used as PWM channels.</p>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#adc-analog-to-digital-converter","title":"ADC (Analog to Digital Converter)","text":"<p>Use the <code>adc</code> module:</p> <pre><code>import adc\n\nval1 := adc.read(ch0)       // read de ADC channel 0\nval2 := adc.read(ch1)       // read de ADC channel 1\n</code></pre>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#functions_3","title":"Functions","text":"name description <code>adc.read(channel)</code> Return the ADC value in <code>channel</code>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#analog-channels","title":"Analog channels","text":"<p>The PWM channels are named from <code>ch0</code> to <code>ch2</code>.</p>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#uart-serial-port","title":"UART (serial port)","text":"<p>Use the <code>uart</code> or <code>uart2</code> module:</p> <pre><code>import uart\n\nuart.print('Hello ')\nuart.println('World...')\n</code></pre>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#functions_4","title":"Functions","text":"name description <code>uart.setup(baud_rate)</code> Configure the <code>baud_rate</code> of the UART <code>uart.read()</code> Return one character received by UART <code>uart.input(message)</code> Send the <code>message</code> and then return the string received by UART <code>uart.write(character)</code> Send one character by UART <code>uart.print(message)</code> Send the <code>message</code> by UART <code>uart.println(message)</code> Send the <code>message</code> plus a new line by UART <code>uart.any()</code> Return the number uf characters in the UART's buffer <code>uart2.setup(baud_rate)</code> Configure the <code>baud_rate</code> of the UART 2 <code>uart2.read()</code> Return one character received by UART 2 <code>uart2.input(message)</code> Send the <code>message</code> and then return the string received by UART 2 <code>uart2.write(character)</code> Send one character by UART 2 <code>uart2.print(message)</code> Send the <code>message</code> by UART 2 <code>uart2.println(message)</code> Send the <code>message</code> plus a new line by UART 2 <code>uart2.any()</code> Return the number uf characters in the UART2's buffer"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#usb-uart-serial-port-by-usb","title":"USB UART (serial port by USB)","text":"<p>Use the <code>usb_uart</code> module:</p> <pre><code>import usb_uart\n\nusb_uart.print('Hello ')\nusb_uart.println('World...')\n</code></pre>"},{"location":"repoFer/Raspberry-Pi/pico/quickref/#functions_5","title":"Functions","text":"name description <code>uart.read()</code> Return one character received by USB-UART <code>uart.input(message)</code> Send the <code>message</code> and then return the string received by USB-UART <code>uart.write(character)</code> Send one character by USB-UART <code>uart.print(message)</code> Send the <code>message</code> by USB-UART <code>uart.println(message)</code> Send the <code>message</code> plus a new line by USB-UART <code>uart.any()</code> Return the number uf characters in the USB-UART's buffer"},{"location":"repoFer/ST/BluePill/STM32F103C/","title":"*Fast guide STM32F103C","text":"<p>This Aixt implementation that supports the card  Blue Pill STM32F103C</p>"},{"location":"repoFer/ST/BluePill/STM32F103C/#id-card-stm32f103c","title":"ID card STM32F103C","text":""},{"location":"repoFer/ST/BluePill/STM32F103C/#view","title":"View","text":"<ul> <li>STM32F103C, a total of 44 interfaces are connected, for example, the pin function definition table is the interface definition.</li> </ul> <p> Image taken from the device datasheet</p>"},{"location":"repoFer/ST/BluePill/STM32F103C/#datasheet","title":"Datasheet","text":"<p>STM32F103C</p>"},{"location":"repoFer/ST/BluePill/STM32F103C/#port-identification","title":"Port Identification","text":"<p>Below are the ports used and their proper designations for programming:</p> No. Name Function 1 VBAT 3.3V power supply; The output current of the external power supply 2 By default, it is enabled as a chip, and the high level is effective 3 Empty feet 4 GPIO11/SPI_SCLK/IIC_SDA/ADC_CH10/JTAG_TDI/TDO 7 R NRST_RESET BUTTON 10 A0 PA0_ADC0_CTS2_T2C1E_WKUP 11 A1 PA1_ADC1_RTS2_T2C2 12 A2 PA2_ADC2_TX2_T2C3 13 A3 PA3_ADC3_RX2_T2C4 14 A4 PA4_ADC4_NSS1_CK2 15 A5 PA5_ADC5_SCK1 16 A6 PA6_ADC6_MISO1_T3C1_T1BKIN 17 A7 PA7_ADC7_MOSI1_T3C2_T1C1N 18 B0 PB0_ADC8_T3C3_T1C2N 19 B1 PB1_ADC9_T3C4_T1C3N 20 BOOT1 PB2_BOOT1 21 B10 PB10_SCL2_TX3_T2C3N 22 B11 PB11_SDA2_RX3_T2C4N 25 B12 PB12_SMBAI2_NSS2_T1BKIN_CK3 26 B13 PB13_SCK2_T1C1N_CTS3 27 B14 PB14_MISO2_T1C2N_RTS3 28 B15 PB15_MOSI2_T1C3N 29 A8 PA8_CK1_T1C1_MCO 30 A9 PA9_TX1_T1C2 31 A10 PA10_RX1_T1C3 32 A11 PA11_USB-_CTS1_T1C4_CANRX 33 A12 PA12_USB+_RTS1_T1ETR_CANTX 34 SWIO SWIO_JTMS_PA13 37 SWCLK SWCLK_JTCK_PA14 38 A15 PA15_JTDI_NSS1_T2C1E 39 B3 PB3_JTDO_SCK1_T2C2_TRACE SWO 40 B4 PB4_JTRST_MISO1_T3C1 41 B5 PB5_SMBAI1_MOSI1_T2C2 42 B6 PB6_SCL1_T4C1_TX1 43 B7 PB7_SDA1_T4C2_RX1 44 BOOT0 BOOT0 45 B8 PB8_SCL1_T4C3_CANRX 46 B9 PB9_SDA1_T4C4_CANTX 5V INPUT 5V BLUE PILL STM32F103C GND GROUND CARD BLUE PILL STM32F103C 3.3V INPUT 3.3V BLUE PILL STM32F103C"},{"location":"repoFer/ST/BluePill/STM32F103C/#digital-input-and-output","title":"Digital input and Output","text":"<p>To identify the digital inputs and outputs, the input and output ports of the card are tested respectively, for this, a code was programmed which allowed the identified ports to be tested one by one, as shown in (image 1): el led est\u00e1 protegido por una resistencia de 330\u2126 PA0,PA1,PA2,PA3,PA4,PA5,PA6,PA7,PB0,PB1,PB10,PB11,PB12,PB13,PB14,PB15,PA8,PA9,PA10,PA11,PA12,PB5,PB6,PB7,PB8,PB9,the aforementioned can also be used as outputs since the card pins allow both functions depending on how they are classified in programming, the difference between these ports or pins will be that some support voltages of exactly 5 volts and others that support voltages lower than 5 volts, to be able to deliver 3.3 volts and 5 volts to the card a burner is used ST-LINK V2  which allows us to select between these two voltages which one we want to deliver and allows us to synchronize the program that we have in the application ARDUINO IDE 2.2.1 for STM32VLD to FLASH  and the card STM32F103C3.</p>"},{"location":"repoFer/ST/BluePill/STM32F103C/#analog-output","title":"Analog Output","text":"<p>To recognize the analog inputs, the same port testing process carried out previously is carried out with the difference that only the ports that allow them to be used to receive and transmit analog signals will be tested, which allow the amplitude and period of the signal to be modified. A signal for this case is reflected when a potentiometer is used, which works as a variable resistor that has a value between 0\u03a9 and 10 k\u03a9 that regulates the level of voltage that will be supplied by this device at the input of our LED,  The LED is protected by a 330\u03a9 resistor, with this circuit which will allow us to observe how the light intensity of the LED varies depending on the value of \u03a9 assigned to the potentiometer, during the verification it is obtained that the ports that allow the transfer of analog signals are A8, A9, A10,B3,B4,B5,B6,B7,B12, B13,B14,B15, for this, a code is programmed which allows the ports previously identified to be identified one by one.</p>"},{"location":"repoFer/ST/BluePill/STM32F103C/#pwm-output","title":"PWM Output","text":"<p>To recognize the PWM signal port of the AIR32F103 card, the ports of the card are tested to find out which of them provides us with this function, so we can obtain a PWM signal using an analog signal as input modulating the width of the pulses generated by the output ports through, during identification it is obtained that the pins that allow the emission of a PWM signal are </p>"},{"location":"repoFer/ST/BluePill/STM32F103C/#uart-communication","title":"UART communication","text":"<p>To identify the ports of the card that allow us to have UART communication, the 3.3 V provided by the AIR32F103 card is used as input, the input voltage is regulated by means of a potentiometer that, by turning its knob and through the communication between The cards through the UART port allow LEDs assigned on the STM32F103C card to be turned on and off. When our voltage regulation device is at its minimum resistance value, the green LED must be on. When it reaches the average resistance value, it must turn on. the yellow LED and when it reaches its maximum resistance value, the Red LED must turn on at the input, an LED must be connected to each port, to do this these two cards will be connected through the generic UART port, that is, connect the PA9 port (TX) of the AIR32F103C card with port PA10 (RX) of the STM32F103C card and port PA10 (RX) of the AIR32F103C card with port PA9 (TX) of the STM32F103C card.</p>"},{"location":"repoFer/ST/BluePill/STM32F103C/#programming-in-v-language","title":"Programming in v language","text":"<p>For each of these modules, you will have a file in .c.v format with the same name of the module and in this you will have the text module followed by the name of the module, example: * module pin * module adc * module pwm</p>"},{"location":"repoFer/ST/BluePill/STM32F103C/#output-port-configuration","title":"Output port configuration","text":"<p>To activate the port to use</p> <pre><code>pin__setup(PIN_NAME, MODE)\n</code></pre> <p>To activate the port to use</p> <pre><code>pin__high(PIN_NAME)\n</code></pre> <ul> <li>Example: If you want to activate the port 17;  <code>pin__high(17)</code>.</li> </ul> <p>To disable the port being used</p> <pre><code>pin__low(PIN_NAME)\n</code></pre> <ul> <li>Example: If you want to disable the port 17;  <code>pin__low(17)</code>.</li> </ul> <p>To disable or enable the port to be used</p> <pre><code>pin__write(PIN_NAME, VALUE)\n</code></pre> <ul> <li>Example: If you want to disable port 17 <code>pin__write(17, 1)</code>, and if you want to activate  <code>pin__write(17, 0)</code>.</li> </ul>"},{"location":"repoFer/ST/BluePill/STM32F103C/#analog-to-digital-ports-adc","title":"Analog to digital ports (ADC)","text":"<p>To configure one of the analog ports</p> <pre><code>adc__setup(PIN_NAME, SETUP_VALUE, ... )\n</code></pre> <ul> <li>In PIN_NAME the name of the analog port is entered, in SETUP_VALUE the VALUE that will be given is said port.</li> </ul> <p>To detect the analog port VALUE</p> <pre><code>x = adc__read(PIN_NAME)\n</code></pre> <ul> <li>In <code>PIN_NAME</code> the name of the analog port is entered, and <code>x</code> takes the VALUE of said port..</li> </ul>"},{"location":"repoFer/ST/BluePill/STM32F103C/#pulse-width-modulation-pwm-outputs","title":"Pulse Width Modulation (PWM outputs)","text":"<p>To configure some PWM</p> <pre><code>pwm__setup(SETUP_VALUE, setup_VALUE_1, ... )\n</code></pre> <ul> <li>In pwm you set the PWM to use, and in SETUP_VALUE the VALUE to which you want to configure said pwm.</li> </ul> <p>To configure the duty cycle of a modulator</p> <pre><code>pwm__duty(duty)\n</code></pre> <ul> <li>In PWM the pwm to be used is set, and in <code>duty</code> the VALUE of the cycle (from 0 to 100) in percentage.</li> </ul>"},{"location":"repoFer/ST/BluePill/STM32F103C/#serial-communication-uart","title":"Serial communication (UART)","text":"<p>The UART used to be the standard stream output, so the functions <code>print()</code>, <code>println()</code> and <code>input()</code> work directly on the default UART. The default UART could change depending on the board or microcontroller, please refer to the specific documentation. The syntax for most of UART functions is: <code>uart_function_name_x()</code>, being <code>x</code> the identifying number in case of multiple UARTs. You can omit the <code>x</code> for referring to the first or default UART, or in the case of having only one.  </p>"},{"location":"repoFer/ST/BluePill/STM32F103C/#uart-setup","title":"UART setup","text":"<pre><code>uart__setup(BAUD_RATE)   // the same of uart__setup(BAUD_RATE)\n</code></pre> <p>For a second connection it is used as:</p> <pre><code>uart__setup_1(BAUD_RATE)   // the same of uart__setup_1(BAUD_RATE)\n</code></pre> <ul> <li><code>BAUD_RATE</code> configure the communication speed</li> </ul>"},{"location":"repoFer/ST/BluePill/STM32F103C/#serial-transmitting","title":"Serial transmitting","text":"<pre><code>uart__print(MESSAGE)      // print a string to the default UART\n</code></pre> <pre><code>uart__println(MESSAGE)    // print a string plus a line-new character to the default UART\n</code></pre> <pre><code>uart__ready // get everything ready for to UART\n</code></pre> <pre><code>uart__read // receives binary data (in Bytes) to UART\n</code></pre> <pre><code>uart__write(MESSAGE)    // send binary data (in Bytes) to second UART\n</code></pre> <ul> <li>For a second UART, it would be used as follows:</li> </ul> <pre><code>uart__print_1(MESSAGE)    // print a string to the second UART\n</code></pre> <pre><code>uart__println_1(MESSAGE)  // print a string plus a line-new character to the second UART\n</code></pre> <pre><code>uart__write_1(MESSAGE)    // send binary data (in Bytes) to second UART\n</code></pre> <pre><code>uart__ready_1 // get everything ready for to second UART\n</code></pre> <pre><code>uart__read_1 // receives binary data (in Bytes) to second UART\n</code></pre>"},{"location":"repoFer/ST/BluePill/STM32F103C/#retardos","title":"Retardos","text":"<ul> <li> <p>Use of times</p> <ul> <li>In each expression, the time VALUE is put inside the parentheses.</li> </ul> </li> </ul> <pre><code>time__sleep(S) //Seconds\n</code></pre> <pre><code>time__sleep_ms(MS) //Milliseconds\n</code></pre> <pre><code>time__sleep_us(US) //Microseconds\n</code></pre> <ul> <li>Example flashing LED</li> </ul> <pre><code>import pin\nimport time {sleep_ms}\n\npin.setup(14, pin.out)\n\nfor {   //infinite loop\n    pin.high(14)\n    sleep_ms(500)\n    pin.low(14)\n    sleep_ms(500)\n}\n</code></pre>"},{"location":"repoFer/ST/BluePill/quickref/","title":"*Fast guide STM32F103C","text":"<p>This Aixt implementation that supports the card  Blue Pill STM32F103C</p>"},{"location":"repoFer/ST/BluePill/quickref/#id-card-stm32f103c","title":"ID card STM32F103C","text":""},{"location":"repoFer/ST/BluePill/quickref/#view","title":"View","text":"<ul> <li>STM32F103C, a total of 44 interfaces are connected, for example, the pin function definition table is the interface definition.</li> </ul> <p> Image taken from the device datasheet</p>"},{"location":"repoFer/ST/BluePill/quickref/#datasheet","title":"Datasheet","text":"<p>STM32F103C To program the card STM32F103C, the ST must be connected,therefore, it is recommended to see the datasheet: ST LINK-V2</p>"},{"location":"repoFer/ST/BluePill/quickref/#port-identification","title":"Port Identification","text":"<p>Below are the ports used and their proper designations for programming:</p> No. Name Function 1 VBAT 3.3V power supply; The output current of the external power supply 2 By default, it is enabled as a chip, and the high level is effective 3 Empty feet 4 GPIO11/SPI_SCLK/IIC_SDA/ADC_CH10/JTAG_TDI/TDO 7 R NRST_RESET BUTTON 10 A0 PA0_ADC0_CTS2_T2C1E_WKUP 11 A1 PA1_ADC1_RTS2_T2C2 12 A2 PA2_ADC2_TX2_T2C3 13 A3 PA3_ADC3_RX2_T2C4 14 A4 PA4_ADC4_NSS1_CK2 15 A5 PA5_ADC5_SCK1 16 A6 PA6_ADC6_MISO1_T3C1_T1BKIN 17 A7 PA7_ADC7_MOSI1_T3C2_T1C1N 18 B0 PB0_ADC8_T3C3_T1C2N 19 B1 PB1_ADC9_T3C4_T1C3N 20 BOOT1 PB2_BOOT1 21 B10 PB10_SCL2_TX3_T2C3N 22 B11 PB11_SDA2_RX3_T2C4N 25 B12 PB12_SMBAI2_NSS2_T1BKIN_CK3 26 B13 PB13_SCK2_T1C1N_CTS3 27 B14 PB14_MISO2_T1C2N_RTS3 28 B15 PB15_MOSI2_T1C3N 29 A8 PA8_CK1_T1C1_MCO 30 A9 PA9_TX1_T1C2 31 A10 PA10_RX1_T1C3 32 A11 PA11_USB-_CTS1_T1C4_CANRX 33 A12 PA12_USB+_RTS1_T1ETR_CANTX 34 SWIO SWIO_JTMS_PA13 37 SWCLK SWCLK_JTCK_PA14 38 A15 PA15_JTDI_NSS1_T2C1E 39 B3 PB3_JTDO_SCK1_T2C2_TRACE SWO 40 B4 PB4_JTRST_MISO1_T3C1 41 B5 PB5_SMBAI1_MOSI1_T2C2 42 B6 PB6_SCL1_T4C1_TX1 43 B7 PB7_SDA1_T4C2_RX1 44 BOOT0 BOOT0 45 B8 PB8_SCL1_T4C3_CANRX 46 B9 PB9_SDA1_T4C4_CANTX 5V INPUT 5V BLUE PILL STM32F103C GND GROUND CARD BLUE PILL STM32F103C 3.3V INPUT 3.3V BLUE PILL STM32F103C"},{"location":"repoFer/ST/BluePill/quickref/#digital-input-and-output","title":"Digital input and Output","text":"<p>To identify the digital inputs and outputs, the input and output ports of the card are tested respectively, for this, a code was programmed which allowed the identified ports to be tested one by one, as shown in (image 1): the led is protected by a resistor de 330\u2126 PA0,PA1,PA2,PA3,PA4,PA5,PA6,PA7,PB0,PB1,PB10,PB11,PB12,PB13,PB14,PB15,PA8,PA9,PA10,PA11,PA12,PB5,PB6,PB7,PB8,PB9,the aforementioned can also be used as outputs since the card pins allow both functions depending on how they are classified in programming, the difference between these ports or pins will be that some support voltages of exactly 5 volts and others that support voltages lower than 5 volts, to be able to deliver 3.3 volts and 5 volts to the card a burner is used ST-LINK V2  which allows us to select between these two voltages which one we want to deliver and allows us to synchronize the program that we have in the application ARDUINO IDE 2.2.1 for STM32VLD to FLASH  and the card STM32F103C3.</p> <p>const int ledPIN1 = PA8; //salida digital al led PA3</p> <p>const int intPIN = PA9; //entrada digital al led PA8 void setup() {   Serial.begin(9600);   // put your setup code here, to run once:   pinMode(ledPIN1, pin.OUTput);//led conectado a salida PA9   pinMode(intPIN, pin.INput);//interruptor conectado a entrada PA8 } void loop() {   // put your main code here, to run repeatedly:   if (digitalRead(intPIN)==LOW){     //INTERRUPTOR PRESIONADO   digitalWrite(ledPIN1, LOW); //LED conectado a PA9  </p> <p>}   else{     //interruptor suelto</p> <p>digitalWrite(ledPIN1, LOW);  //LED conectado a PA9</p> <p>}\u00a0\u00a0 \u00a0delay\u00a0(1); }</p>"},{"location":"repoFer/ST/BluePill/quickref/#analog-output","title":"Analog Output","text":"<p>To recognize the analog inputs, the same port testing process carried out previously is carried out with the difference that only the ports that allow them to be used to receive and transmit analog signals will be tested, which allow the amplitude and period of the signal to be modified. A signal for this case is reflected when a potentiometer is used, which works as a variable resistor that has a value between 0\u03a9 and 10 k\u03a9 that regulates the level of voltage that will be supplied by this device at the input of our LED,  The LED is protected by a 330\u03a9 resistor, with this circuit which will allow us to observe how the light intensity of the LED varies depending on the value of \u03a9 assigned to the potentiometer, during the verification it is obtained that the ports that allow the transfer of analog signals are A8, A9, A10,B3,B4,B5,B6,B7,B12, B13,B14,B15, for this, a code is programmed which allows the ports previously identified to be identified one by one.</p>"},{"location":"repoFer/ST/BluePill/quickref/#pwm-output","title":"PWM Output","text":"<p>To recognize the PWM signal port of the AIR32F103 card, the ports of the card are tested to find out which of them provides us with this function, so we can obtain a PWM signal using an analog signal as input modulating the width of the pulses generated by the output ports through, during identification it is obtained that the pins that allow the emission of a PWM signal are.</p> <p>example for PWM and Analog</p> <p>define LED_BUILTIN 2</p>"},{"location":"repoFer/ST/BluePill/quickref/#include-httpsgithubcomfellipecoutopwmoutesp32-httpwwwefeitonerdcombr","title":"include  //https://github.com/fellipecouto/PWMOutESP32 [ http://www.efeitonerd.com.br ] <p>//Resolution between 1 and 16 (bits). Frequency between 1 and 40000 (Hz) PWMOutESP32 pwm(10, 5000); //Resolution=10bits, Frequency=5000Hz</p> <p>void setup() {   Serial.begin(115200);   pinMode(LED_BUILTIN, pin.OUTput);</p> <p>Serial.println(\"\\nPWMOutESP32\");   Serial.println(\"Library for controlling ESP32 PWM outputs similar to use on Arduino\");   Serial.print(\"Maximum PWM value for the configured resolution: \");   Serial.println(pwm.getMaxPWMValue()); }</p> <p>void loop() {</p> <p>for (int fadeValue = 0; fadeValue &lt;= pwm.getMaxPWMValue(); fadeValue++)  {     pwm.analogWrite(LED_BUILTIN, fadeValue);     delay(2);   }   delay(500);</p> <p>for (int fadeValue = pwm.getMaxPWMValue(); fadeValue &gt;= 0; fadeValue--)  {     pwm.analogWrite(LED_BUILTIN, fadeValue);     delay(2);   }   delay(500);</p> <p>}</p>","text":""},{"location":"repoFer/ST/BluePill/quickref/#uart-communication","title":"UART communication","text":"<p>To identify the ports of the card that allow us to have UART communication, the 3.3 V provided by the AIR32F103 card is used as input, the input voltage is regulated by means of a potentiometer that, by turning its knob and through the communication between The cards through the UART port allow LEDs assigned on the STM32F103C card to be turned on and off. When our voltage regulation device is at its minimum resistance value, the green LED must be on. When it reaches the average resistance value, it must turn on. the yellow LED and when it reaches its maximum resistance value, the Red LED must turn on at the input, an LED must be connected to each port, to do this these two cards will be connected through the generic UART port, that is, connect the PA9 port (TX) of the AIR32F103C card with port PA10 (RX) of the STM32F103C card and port PA10 (RX) of the AIR32F103C card with port PA9 (TX) of the STM32F103C card.</p> <p>example:</p>"},{"location":"repoFer/ST/BluePill/quickref/#programming-in-v-language","title":"Programming in v language","text":"<p>For each of these modules, you will have a file in .c.v format with the same name of the module and in this you will have the text module followed by the name of the module, example: * module pin * module adc * module pwm</p>"},{"location":"repoFer/ST/BluePill/quickref/#output-port-configuration","title":"Output port configuration","text":"<p>To activate the port to use</p> <pre><code>pin.setup(pin_name, mode)\n</code></pre> <p>To activate the port to use</p> <pre><code>pin.high(PIN_NAME)\n</code></pre> <ul> <li>Example: If you want to activate the port 17;  <code>pin.high(17)</code>.</li> </ul> <p>To disable the port being used</p> <pre><code>pin.low(PIN_NAME)\n</code></pre> <ul> <li>Example: If you want to disable the port 17;  <code>pin.low(17)</code>.</li> </ul> <p>To disable or enable the port to be used</p> <pre><code>pin.write(PIN_NAME, VALUE)\n</code></pre> <ul> <li>Example: If you want to disable port 17 <code>pin.write(17, 1)</code>, and if you want to activate  <code>pin.write(17, 0)</code>.</li> </ul>"},{"location":"repoFer/ST/BluePill/quickref/#analog-to-digital-ports-adc","title":"Analog to digital ports (ADC)","text":"<p>To configure one of the analog ports</p> <pre><code>adc.setup(PIN_NAME, SETUP_VALUE, ... )\n</code></pre> <ul> <li>In PIN_NAME the name of the analog port is entered, in SETUP_VALUE the VALUE that will be given is said port.</li> </ul> <p>To detect the analog port VALUE</p> <pre><code>x = adc.read(PIN_NAME)\n</code></pre> <ul> <li>In <code>PIN_NAME</code> the name of the analog port is entered, and <code>x</code> takes the VALUE of said port..</li> </ul>"},{"location":"repoFer/ST/BluePill/quickref/#pulse-width-modulation-pwm-outputs","title":"Pulse Width Modulation (PWM outputs)","text":"<p>To configure some PWM</p> <pre><code>pwm.setup(SETUP_VALUE, setup_VALUE_1, ... )\n</code></pre> <ul> <li>In pwm you set the PWM to use, and in SETUP_VALUE the VALUE to which you want to configure said pwm.</li> </ul> <p>To configure the duty cycle of a modulator</p> <pre><code>pwm.write(duty)\n</code></pre> <ul> <li>In PWM the pwm to be used is set, and in <code>duty</code> the VALUE of the cycle (from 0 to 100) in percentage.</li> </ul>"},{"location":"repoFer/ST/BluePill/quickref/#serial-communication-uart","title":"Serial communication (UART)","text":"<p>The UART used to be the standard stream output, so the functions <code>print()</code>, <code>println()</code> and <code>input()</code> work directly on the default UART. The default UART could change depending on the board or microcontroller, please refer to the specific documentation. The syntax for most of UART functions is: <code>uart_function_name_x()</code>, being <code>x</code> the identifying number in case of multiple UARTs. You can omit the <code>x</code> for referring to the first or default UART, or in the case of having only one.  </p>"},{"location":"repoFer/ST/BluePill/quickref/#uart-setup","title":"UART setup","text":"<pre><code>uart.setup(BAUD_RATE)   // the same of uart.setup(BAUD_RATE)\n</code></pre> <p>For a second connection it is used as:</p> <pre><code>uart.setup_1(BAUD_RATE)   // the same of uart.setup_1(BAUD_RATE)\n</code></pre> <ul> <li><code>BAUD_RATE</code> configure the communication speed</li> </ul>"},{"location":"repoFer/ST/BluePill/quickref/#serial-transmitting","title":"Serial transmitting","text":"<pre><code>uart.print(message)      // print a string to the default UART\n</code></pre> <pre><code>uart.println(message)    // print a string plus a line-new character to the default UART\n</code></pre> <pre><code>uart.ready // get everything ready for to UART\n</code></pre> <pre><code>uart.read // receives binary data (in Bytes) to UART\n</code></pre> <pre><code>uart.write(MESSAGE)    // send binary data (in Bytes) to second UART\n</code></pre> <ul> <li>For a second UART, it would be used as follows:</li> </ul> <pre><code>uart.print_1(MESSAGE)    // print a string to the second UART\n</code></pre> <pre><code>uart.println_1(MESSAGE)  // print a string plus a line-new character to the second UART\n</code></pre> <pre><code>uart.write_1(MESSAGE)    // send binary data (in Bytes) to second UART\n</code></pre> <pre><code>uart.ready_1 // get everything ready for to second UART\n</code></pre> <pre><code>uart.read_1 // receives binary data (in Bytes) to second UART\n</code></pre>"},{"location":"repoFer/ST/BluePill/quickref/#retardos","title":"Retardos","text":"<ul> <li> <p>Use of times</p> <ul> <li>In each expression, the time VALUE is put inside the parentheses.</li> </ul> </li> </ul> <pre><code>time.sleep(S) //Seconds\n</code></pre> <pre><code>time.sleep_ms(MS) //Milliseconds\n</code></pre> <pre><code>time.sleep_us(US) //Microseconds\n</code></pre> <ul> <li>Example flashing LED</li> </ul> <pre><code>import pin\nimport time {sleep_ms}\n\npin.setup(14, pin.output)\n\nfor {   //infinite loop\n    pin.high(14)\n    sleep_ms(500)\n    pin.low(14)\n    sleep_ms(500)\n}\n</code></pre>"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/","title":"Quick Guide Seeeduino Xiao","text":"<p>This is an Aixt implementation to provide support for the SAMD21 board.</p>"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#summary","title":"Summary","text":"<ul> <li>SAMD21 has 14 pins, which can be used for 11 digital interfaces, 11 simulated interfaces, 10 PWM interfaces (d1-d10), 1 DAC output pin D0, 1 SWD pad interface, 1 I2C interface, 1 SPI interface, 1 UART interface, Serial communication indicator (T/R), Flashing light (L) through pin multiplexing. The LED colors (Power, L, RX, TX) are green, yellow, blue, and blue. Additionally, Seeed Studio XIAO SAMD21 has a Type-C interface that can supply power and download code. There are two reset buttons, you can briefly connect them to reset the board. The pin definition is described in the* Pin Identification table.</li> </ul> <p> ***Getting Started with Seeed Studio XIAO SAMD21.\" (n.d.). Retrieved February 17, 2024, from: https://wiki.seeedstudio.com/Seeeduino-XIAO/</p>"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#datasheet","title":"Datasheet","text":"<p>Seeeduino Xiao SAMD21G18A-MU </p>"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#pin-identification","title":"Pin Identification","text":"Pin No. Name Function 0 D0-A0-DAC-QT0 Analog; Digital; Analog to Digital Converter; Capacitive touch button integrated circuit 1 D1-A1-QT1 Analog; Digital; Capacitive touch button integrated circuit 2 D2-A2 Analog; Digital 3 D3-A3 Analog; Digital 4 D4-A4-SDA(I2C) Analog; Digital; Inter-Integrated Circuit (I2C) Protocol (Data Transmission) 5 D5-A5-SCL(I2C) Analog; Digital; Inter-Integrated Circuit (I2C) Protocol (Clock Synchronization) 6 D6-A6-TX-QT2 Analog; Digital; Serial Communication (Transmitter); Capacitive touch button integrated circuit 7 D7-A7-RX-QT3 Analog; Digital; Serial Communication (Receiver); Capacitive touch button integrated circuit 8 D8-A8-SCK(SPI)-QT4 Analog; Digital; Serial Clock; Capacitive touch button integrated circuit 9 D9-A9-MISO(SPI)-QT5 Analog; Digital; 4-Wire Communication Protocol; Capacitive touch button integrated circuit 10 D10-A10-MOSI(SPI)-QT6 Analog; Digital; 4-Wire Communication Protocol; Capacitive touch button integrated circuit 11 3.3V Microcontroller Power Supply 12 GND Ground 13 5V Board Power Supply"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#programming-in-v-language","title":"Programming in V Language","text":"<p>The functions contained in the API for digital input or output and for performing analog to digital conversion.</p> Name Description Examples <code>pin.setup(pin, pin.mode)</code> Configure <code>pin</code> as <code>mode</code> (input, out) pin.setup(5, input) // Set pin 5 as input <code>output</code> Parameter <code>mode</code> output configuration pin.setup(3, output) // Set pin 3 as output <code>input</code> Parameter <code>mode</code> input configuration pin.setup(7, input) // Set pin 7 as input <code>pin.high(pin)</code> Digital output high <code>pin</code> pin.high(3) // Output high on pin 3 <code>pin.low(pin)</code> Digital output low <code>pin</code> pin.low(3) // Output low on pin 3 <code>pin.write(pin, val)</code> Write <code>val</code> to <code>pin</code> pin.write(3, 1) // Write 1 to pin 3 <code>pin.read(pin)</code> Digital read <code>pin</code> val=pin.read(3) // Read pin 3 and store in val <code>adc.read(pin)</code> Analog read <code>pin</code> for <code>adc</code> val=adc.read(3) // Read analog value of pin 3 and store in val <code>pwm.write(pin, val)</code> PWM output <code>pin</code> with duty cycle <code>val</code> pwm.write(4, 125) // Write PWM signal with duty cycle of 125 to pin 3 <code>uart.setup(baud_rate)</code> Serial Communication initiation at <code>Baud.rate</code> uart.setup(9600) // Initialize serial communication at 9600 baud rate <code>uart.any()</code> Get the number of bytes to read val=uart.any() // Get the number of bytes to read from serial port and store in val <code>uart.read()</code> Serial Communication read lec=uart.read() // Read from serial port and store in lec <code>uart.println(\"message\")</code> Print <code>message</code> through Serial Communication uart.println(\"Hello world\") // Print \"Hello world\" through serial port <code>time.sleep(time)</code> Retardo en <code>seg</code> time.sleep(5) // 5 seconds delay <code>time.sleep_us(time)</code> Retardo en <code>microseg</code> time.sleep_us(250) // 250 microseconds delay <code>time.sleep_ms(time)</code> Retardo en <code>miliseg</code> time.sleep_ms(250) // 250 milliseconds delay"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#examples","title":"EXAMPLES","text":""},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#example-of-transcompilation-and-compilation-on-youtube","title":"Example of Transcompilation and Compilation on YouTube.","text":"<p>Link: https://youtu.be/Wi4j1mvfa_0</p>"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#led-blinking","title":"LED Blinking","text":"<p>Next, an LED will be turned on and off 10 times.</p> <pre><code>import time {sleep_ms}   // Import the sleep_ms function from the time module \nimport pin  // Import the pin module in its entirety\n\npin.mode(5, pin.output)    // Set pin #5 as output\n\nfor i in 0..10{   // 10 times\n    pin.high(5)     // Output high (Turn on the LED)\n    sleep_ms(500)   // Delay for 0.5s\n    pin.low(5)      // Output low (Turn off the LED)\n    sleep_ms(500)   // Delay for 0.5s\n}\nfor{}       // Infinite loop necessary for compilation\n</code></pre>"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#sequence-of-3-leds","title":"Sequence of 3 LEDs","text":"<p>Next, a sequence of 3 LEDs will be shown.</p> <pre><code>import time {sleep_ms} // Import the sleep_ms function\nimport pin  // Import the pin module\n\npin.setup(3, pin.output)    // Set pin #3 as output\npin.setup(4, pin.output)    // Set pin #4 as output\npin.setup(5, pin.output)    // Set pin #5 as output\n\nfor{\n    pin.high(3)     // Output high\n    sleep_ms(250)   // Delay for 250 milliseconds\n    pin.high(4)     // Output high\n    sleep_ms(250)   // Delay for 250 milliseconds\n    pin.high(5)     // Output high\n    sleep_ms(250)   // Delay for 250 milliseconds\n    pin.low(3)      // Output low\n    sleep_ms(250)   // Delay for 250 milliseconds\n    pin.low(4)      // Output low\n    sleep_ms(250)   // Delay for 250 milliseconds\n    pin.low(5)      // Output low\n    sleep_ms(250)   // Delay for 250 milliseconds\n}\n</code></pre>"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#turn-on-an-led-with-a-button","title":"Turn on an LED with a Button","text":"<p>Next, the turning on of an LED will be conditioned to a button.</p> <pre><code>import pin  // Import the pin module\n\n__global (\n    reading = 0      // Create a global variable to store digital reading\n)    \n\npin.setup(3, pin.input)     // Set pin #3 as input\npin.setup(5, pin.output)       // Set pin #5 as output\n\nfor{        // Infinite loop\n    reading=pin.read(3)     // Store digital reading of pin #3\n    if reading==1{         // Condition if reading value is 1 (High)\n        pin.high(5);        // Output high\n    }\n    pin.low(5)              // Output low \n}\n</code></pre>"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#analog-reading","title":"Analog Reading","text":"<pre><code>import pin  // import the pin module\nimport adc  // import the adc module\n\n__global (\n    val = 0      // Create a global variable to store the analog reading\n)     \npin.setup(2, pin.output)   // Set pin #2 as output\npin.setup(3, pin.output)   // Set pin #3 as output\npin.setup(4, pin.output)   // Set pin #4 as output\n\n\nfor {       // Infinite loop\n    val = adc.read(8)     // Store the analog reading of pin #8\n    if val &gt;= 1000 {      // Condition for the analog reading\n        pin.high(2)     // Output high\n        pin.high(3)     // Output high\n        pin.high(4)     // Output high\n    }\n    else if val &gt;= 750 {\n        pin.high(2)     // Output high\n        pin.high(3)     // Output high\n        pin.low(4)      // Output low\n    }\n    else if val &gt;= 480 {\n        pin.high(2)     // Output high\n        pin.low(3)      // Output low\n        pin.low(4)      // Output low\n    }\n    else {\n        pin.low(2)      // Output low\n        pin.low(3)      // Output low\n        pin.low(4)      // Output low  \n    }   \n    }\n</code></pre>"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#pwm-output","title":"PWM Output","text":"<pre><code>import time {sleep_ms}  // import the sleep_ms function\nimport pin              // import the pin module\nimport pwm              // import the pwm module\n\n__global (\n    val = 0        // Create a global variable to store a value corresponding to the luminous intensity\n)      \n\npin.setup(5, pin.output)   // Set pin #5 as output\n\n\nfor {\n    pwm.write(5, val)   // PWM output with a duty cycle of val\n    sleep_ms(250)       // Delay of 250ms\n    val = val + 10      // Add 10 to val\n    if val == 250 {     // Condition if val equals 250\n        val = 0  \n    }\n} \n</code></pre>"},{"location":"repoFer/Seeed-Studio/XIAO-SAMD21/quickref/#serial-communication","title":"Serial Communication","text":"<pre><code>import pin      // import the pin module\nimport uart     // import the uart module\n\n __global (\n    num = 0    // Create a global variable to store the number of bytes to read from the serial port\n    lec = 0    // Create a global variable to store the reading from the serial port\n )\n\n pin.setup(3, pin.output)      // Set pin #3 as output\n uart.setup(9600)           // Set the baud rate to 9600\n\nfor {\n    num = uart.any()      // Store the number of bytes to read from the serial port\n    if  num &gt; 0  {          // Condition if the number of bytes to read is greater than 0\n        lec = uart.read()   // Store the reading from the serial port\n        if lec == `1` {     // Condition when the reading is 1\n\n            pin.high(3)     // Output high\n            uart.println('Led on')   // Message on the serial port\n\n        }\n\n        else if lec == `2` {    // Condition when the reading is 2\n\n            pin.low(3)      // Output low\n            uart.println('Led off')     // Message on the serial port\n\n        }\n    }\n}\n</code></pre>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/","title":"Guia Rapida Seeeduino Xiao","text":"<p>Esta implementaci\u00f3n de Aixt para dae soporte a la tarjeta SAMD21.</p>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#resumen","title":"Resumen","text":"<ul> <li>SAMD21, tiene 14 PIN, que se pueden usar para 11 interfaces digitales, 11 interfaces simuladas, 10 interfaces PWM (d1-d10), 1 pin de salida DAC D0, 1 interfaz de pad SWD, 1 interfaz I2C, 1 interfaz SPI, 1 Interfaz UART, Indicador de comunicaci\u00f3n serial (T/R), Luz parpadeante (L) mediante multiplexaci\u00f3n de pines. Los colores de los LED (Power,L,RX,TX) son verde, amarillo, azul y azul. Adem\u00e1s, Seeed Studio XIAO SAMD21 tiene una interfaz tipo C que puede suministrar energ\u00eda y descargar c\u00f3digo. Hay dos botones de reinicio, puedes conectarlos brevemente para reiniciar la placa.La definici\u00f3 de pines esta descrita en la tala de Identificaci\u00f3n de Pines.</li> </ul>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#datasheet","title":"Datasheet","text":"<p>Seeeduino Xiao SAMD21</p>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#identificacion-de-pines","title":"Identificaci\u00f3n de Pines","text":"<p>Below are the ports used and their proper designations for programming:</p> Pin No. Nombre Funci\u00f3n 0 D0-A0-DAC-QT0 Analogo; Digital; Convertidor Analogo Digital;            Circuito integrado para bot\u00f3n capacitivo 1 D1-A1-QT1 Analogo; Digital;                                         Circuito integrado para bot\u00f3n capacitivo 2 D2-A2 Analogo; Digital; 3 D3-A3 Analogo; Digital; 4 D4-A4-SDA(I2C) Analogo; Digital; Protocolo control de dispositivos(Transmisi\u00f3n de datos) 5 D5-A5-SCL(I2C) Analogo; Digital; Protocolo control de dispositivos(Envio sincronismos de reloj) 6 D6-A6-TX-QT2 Analogo; Digital; Comunicaci\u00f3n Serial(Transmisor);        Circuito integrado para bot\u00f3n capacitivo 7 D7-A7-RX-QT3 Analogo; Digital; Comunicaci\u00f3n Serial(Receptor);          Circuito integrado para bot\u00f3n capacitivo 8 D8-A8-SCK(SPI)-QT4 Analogo; Digital; Reloj serial;                           Circuito integrado para bot\u00f3n capacitivo 9 D9-A9-MISO(SPI)-QT5 Analogo; Digital; Protocolo de comunicaci\u00f3n 4 hilos;      Circuito integrado para bot\u00f3n capacitivo 10 D10-A10-MOSI(SPI)-QT6 Analogo; Digital; Protocolo de comunicaci\u00f3n 4 hilos;      Circuito integrado para bot\u00f3n capacitivo 11 3.3V Alimentaci\u00f3n de Microcontrolador 12 GND Tierra Com\u00fan 13 5V Alimentaci\u00f3n de la Placa"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#programacion-en-lenguaje-v","title":"Programaci\u00f3n en Lenguaje V","text":"<p>Las funciones que contiene la API entradas o salidas digitales y para realizar una conversi\u00f3n analogico a digital.</p> Nombre Descripci\u00f3n <code>pin.setup(pin, mode)</code> Configura <code>pin</code>como <code>mode</code> (input, out) <code>pin.high(pin)</code> Salida Digital en alto <code>pin</code> <code>pin.low(pin)</code> Salida Digital en bajo <code>pin</code> <code>pin.write(pin, val)</code> Escribe <code>val</code> en <code>pin</code> <code>pin.read(pin)</code> Entrada digital <code>pin</code> <code>adc.read(pin)</code> Lectura analogica <code>pin</code> para el <code>adc</code> <code>pwm.write(pin, val)</code> Salida <code>pin</code> y un ciclo util de <code>val</code> <code>uart.setup(baund_rate)</code> Iniciaci\u00f3n Comunicac\u00f3n Serial a <code>Baund_rate</code> <code>uart.read()</code> Lectura de Comunicac\u00f3n Serial a `` <code>println(message)</code> Imprime  <code>message</code> a traves Comunicac\u00f3n Serial <code>sleep(time)</code> Retardo en <code>seg</code> <code>sleep_us(time)</code> Retardo en <code>microseg</code> <code>sleep_ms(time)</code> Retardo en <code>miliseg</code>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#ejemplos","title":"EJEMPLOS","text":""},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#parpadeo-de-un-led","title":"Parpadeo de un LED","text":"<pre><code>pin_mode(5, out)\n\nfor i in 0..10{   //10 veces\n    pin.high(5)\n    sleep_ms(500)\n    pin.low(5)\n    sleep_ms(500)\n}\n</code></pre>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#ejemplo-lectura-analoga","title":"Ejemplo lectura analoga","text":"<pre><code>\npin.setup(2, out)\npin.setup(3, out)\npin.setup(4, out)\nfor {\n    if( adc.read(8)&gt;=1017 ){\n\n        pin.high(2)\n        pin.high(3)\n        pin.high(4)\n\n    }\n    else if( adc.read(8)&gt;=750 ){\n\n        pin.high(2)\n        pin.high(3)\n        pin.low(4)\n\n    }\n    else if( adc.read(8)&gt;=480 ){\n\n        pin.high(2)\n        pin.low(3)\n        pin.low(4)\n\n    }\n    else {\n\n        pin.low(2)\n        pin.low(3)\n        pin.low(4)\n\n    }\n    } \n</code></pre>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#ejemplo-salida-pwm","title":"Ejemplo salida PWM","text":"<pre><code>\npin.setup(5, out)\nint util=0\n\nfor {\n    pwm.write(5, util)\n    sleep_ms(250)\n    util=util+10\n    if (util==250){\n\n        util=0\n\n    }\n    } \n</code></pre>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#encender-un-led-con-u-pulsador","title":"Encender un LED con u pulsador","text":"<pre><code>pin_mode(3, out)\n\nfor {   //infinite loop\n    pin.high(5)\n    sleep_ms(500)\n    pin.low(5)\n    sleep_ms(500)\n}\n</code></pre>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#configuracion-pines-de-salida","title":"Configuraci\u00f3n Pines de Salida","text":"<p>To activate the port to use</p> <pre><code>pin.high(pin_name)\n</code></pre> <ul> <li>Example: If you want to activate the port IO17;  <code>pin.high(IO17)</code>.</li> </ul> <p>To disable the port being used</p> <pre><code>pin.low(pin_name)\n</code></pre> <ul> <li>Example: If you want to disable the port IO17;  <code>pin.low(O17I)</code>.</li> </ul> <p>To disable or enable the port to be used</p> <pre><code>pin.write(pin_name, value)\n</code></pre> <ul> <li>Example: If you want to disable port IO17 <code>pin.write(IO17, 1)</code>, and if you want to activate  <code>pin.write(IO17, 0)</code>.</li> </ul>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#input-port-detection","title":"Input port detection","text":"<p>If you need to know what state an entry port is in:</p> <pre><code>x = pin.read(pin_name)\n</code></pre> <ul> <li>Example: If you want to detect the value of port IO3; <code>x = pin.read(IO17)</code>, and <code>x</code> will take the value of 0 or 1, depending on which port is active or disabled.</li> </ul>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#analog-to-digital-ports-adc","title":"Analog to digital ports (ADC)","text":"<p>To configure one of the analog ports</p> <pre><code>adc.setup(channel, setup_value_1, ... )\n</code></pre> <ul> <li>In channel the name of the analog port is entered, in setup_value_1 the value that will be given is said port.</li> </ul> <p>To detect the analog port value</p> <pre><code>x = adc.read(channel)\n</code></pre> <ul> <li>In <code>channel</code> the name of the analog port is entered, and <code>x</code> takes the value of said port..</li> </ul>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#pulse-width-modulation-pwm-outputs","title":"Pulse Width Modulation (PWM outputs)","text":"<p>To configure some PWM</p> <pre><code>pwm.setup(setup_value_1, setup_value_2, ... )\n</code></pre> <ul> <li>In pwm you set the PWM to use, and in setup_value_1 the value to which you want to configure said pwm.</li> </ul> <p>To configure the duty cycle of a modulator</p> <pre><code>pwm_duty(duty)\n</code></pre> <ul> <li>In PWM the pwm to be used is set, and in <code>duty</code> the value of the cycle (from 0 to 100) in percentage.</li> </ul>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#serial-communication-uart","title":"Serial communication (UART)","text":"<p>The UART used to be the standard stream output, so the functions <code>print()</code>, <code>println()</code> and <code>input()</code> work directly on the default UART. The default UART could change depending on the board or microcontroller, please refer to the specific documentation. The syntax for most of UART functions is: <code>uartx_function_name()</code>, being <code>x</code> the identifying number in case of multiple UARTs. You can omit the <code>x</code> for referring to the first or default UART, or in the case of having only one.  </p>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#uart-setup","title":"UART setup","text":"<pre><code>uart.setup(baud_rate)   // the same of uart1_setup(baud_rate)\n</code></pre> <ul> <li><code>baud_rate</code> configure the communication speed</li> </ul>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#serial-transmitting","title":"Serial transmitting","text":"<pre><code>print(message)      // print a string to the default UART\n</code></pre> <pre><code>println(message)    // print a string plus a line-new character to the default UART\n</code></pre> <pre><code>uart2_print(message)    // print a string to the UART2\n</code></pre> <pre><code>uart1_println(message)  // print a string plus a line-new character to the UART1\n</code></pre> <pre><code>uart2_write(message)    // send binary data (in Bytes) to UART2\n</code></pre>"},{"location":"repoFer/Seeeduino_Xiao/samd21/quickref/#retardos","title":"Retardos","text":"<ul> <li> <p>Use of times</p> <ul> <li>In each expression, the time value is put inside the parentheses.</li> </ul> </li> </ul> <pre><code>time.sleep(s) //Seconds\n</code></pre> <pre><code>time.sleep_ms(ms) //Milliseconds\n</code></pre> <pre><code>time.sleep_us(us) //Microseconds\n</code></pre> <ul> <li>Example flashing LED</li> </ul> <pre><code>import machine { pin }\nimport time { sleep_ms }\n\npin_mode(IO14, out)\n\nfor {   //infinite loop\n    pin.high(IO14)\n    sleep_ms(500)\n    pin.low(IO14)\n    sleep_ms(500)\n}\n</code></pre>"},{"location":"repoFer/W801/quickref/","title":"*Fast guide W801","text":"<p>This Aixt implementation that supports the card W801</p>"},{"location":"repoFer/W801/quickref/#id-card-w801","title":"ID card W801","text":""},{"location":"repoFer/W801/quickref/#view","title":"View","text":"<ul> <li>W801, a total of 44 interfaces are connected, for example, the pin function definition table is the interface definition.</li> </ul> <p> Image taken from the device datasheet</p>"},{"location":"repoFer/W801/quickref/#datasheet","title":"Datasheet","text":"<p>W801</p>"},{"location":"repoFer/W801/quickref/#port-identification","title":"Port Identification","text":"<p>Below are the ports used and their proper designations for programming:</p> No. Name Function 1 PB_18 GPIO, entrada, alta impedancia  UART5_TX/LCD_SEG30 2 PB_26 GPIO, entrada, alta impedancia  LSPI_MOSI/PWM4/LCD_SEG1 3 PB_25 GPIO, entrada, alta impedancia  LSPI_MISO/PWM3/LCD_COM0 4 PB_24 GPIO, entrada, alta impedancia  LSPI_CK/PWM2/LCD_SEG2 5 PB_23 GPIO, entrada, alta impedancia  LSPI_CS/PCM_DATA/LCD_SEG0 6 PB_22 GPIO, entrada, alta impedancia  UART0_CTS/PCM_CK/LCD_COM2 7 PB_21 GPIO, entrada, alta impedancia  UART0_RTS/PCM_SYNC/LCD_COM1 8 PB_20 UART_RX     UART0_RX/PWM1/UART1_CTS/I2C_SCL 9 PB_19 UART_TX     UART0_TX/PWM0/UART1_RTS/I2C_SDA 10 RESET REINICIAR restablecer 11 XTAL_OUT Salida de oscilador de cristal externo 12 XTAL_IN Entrada de oscilador de cristal externo 13 AVDD33 Fuente de alimentaci\u00f3n del chip, 3,3 V. 14 ANT antena de radiofrecuencia 15 AVDD33 Fuente de alimentaci\u00f3n del chip, 3,3 V. 16 AVDD33 Fuente de alimentaci\u00f3n del chip, 3,3 V. 17 AVDD33_AUX Fuente de alimentaci\u00f3n del chip, 3,3 V. 18 BOOTMODE EL MODO DE INICIO   I2S_MCLK/LSPI_CS/PWM2/I2S_DO 19 PA_1 JTAG_CK JTAG_CK/I2C_SCL/PWM3/I2S_LRCK/ADC_1 20 PA_2 GPIO, entrada, alta impedancia  UART1_RTS/UART2_TX/PWM0/UART3_RTS/ADC_4 21 PA_3 GPIO, entrada, alta impedancia  UART1_CTS/UART2_RX/PWM1/UART3_CTS/ADC_3 22 PA_4 JTAG_SWO    JTAG_SWO/I2C_SDA/PWM4/I2S_BCK/AD C_2 23 PA_5 GPIO, entrada, alta impedancia  UART3_TX/UART2_RTS/PWM_BREAK/UART4_RTS/VRP_EXT 24 PA_6 GPIO, entrada, alta impedancia  UART3_RX/UART2_CTS/NULL/UART4_CTS/LCD_SEG31/VRP_EXT 25 PA_7 GPIO, entrada, alta impedancia  PWM4/LSPI_MOSI/I2S_MCK/I2S_DI/LC D_SEG3/Touch_1 26 PA_8 GPIO, entrada, alta impedancia  PWM_BREAK/UART4_TX/UART5_TX/I2S_ BCLK/LCD_SEG4 27 PA_9 GPIO, entrada, alta impedancia  MMC_CLK/UART4_RX/UART5_RX/I2S_LRCLK/LCD_SEG5/TOUCH_2 28 PA_10 GPIO, entrada, alta impedancia  MMC_CMD/UART4_RTS/PWM0/I2S_DO/LCD_SEG6/TOUCH_3 29 VDD33IO Fuente de alimentaci\u00f3n IO, 3,3 V 30 PA_11 GPIO, entrada, alta impedancia  MMC_DAT0/UART4_CTS/PWM1/I2S_DI/L CD_SEG7 31 PA_12 GPIO, entrada, alta impedancia  MMC_DAT1/UART5_TX/PWM2/LCD_SEG8/ TOUCH_14 32 PA_13 GPIO, entrada, alta impedancia  MMC_DAT2/UART5_RX/PWM3/LCD_SEG9 33 PA_14 GPIO, entrada, alta impedancia  MMC_DAT3/UART5_CTS/PWM4/LCD_SEG1 0/TOUCH_15 34 PA_15 GPIO, entrada, alta impedancia  PSRAM_CK/UART5_RTS/PWM_BREAK/LCD _SEG11 35 PB_0 GPIO, entrada, alta impedancia  PWM0/LSPI_MISO/UART3_TX/PSRAM_CK /LCD_SEG12/Touch_4 36 PB_1 GPIO, entrada, alta impedancia  PWM1/LSPI_CK/UART3_RX/PSRAM_CS/L CD_SEG13/Touch_5 37 PB_2 GPIO, entrada, alta impedancia  PWM2/LSPI_CK/UART2_TX/PSRAM_D0/L CD_SEG14/Touch_6 38 PB_3 GPIO, entrada, alta impedancia  PWM3/LSPI_MISO/UART2_RX/PSRAM_D1 /LCD_SEG15/Touch_7 39 PB_27 GPIO, entrada, alta impedancia  PSRAM_CS/UART0_TX/LCD_COM3 40 PB_4 GPIO, entrada, alta impedancia  LSPI_CS/UART2_RTS/UART4_TX/PSRAM_D2/LCD_SEG16/Touch_8 41 PB_5 GPIO, entrada, alta impedancia  LSPI_MOSI/UART2_CTS/UART4_RX/PSARM_D3/LCD_SEG17/Touch_9 42 VDD33IO Fuente de alimentaci\u00f3n IO, 3,3 V 43 CAP Condensador externo, 1 \u00b5F 44 PB_6 GPIO, entrada, alta impedancia  UART1_TX/MMC_CLK/HSPI_CK/SDIO_CK /LCD_SEG18/Touch_10 45 PB_7 GPIO, entrada, alta impedancia  UART1_RX/MMC_CMD/HSPI_INT/SDIO_C MD/LCD_SEG19/Touch_11 46 PB_8 GPIO, entrada, alta impedancia  I2S_BCK/MMC_D0/PWM_BREAK/SDIO_D0 /LCD_SEG20/Touch_12 47 PB_9 GPIO, entrada, alta impedancia  I2S_LRCK/MMC_D1/HSPI_CS/SDIO_D1/ LCD_SEG21/Touch_13 48 PB_12 GPIO, entrada, alta impedancia  HSPI_CK/PWM0/UART5_CTS/I2S_BCLK/ LCD_SEG24 49 PB_13 GPIO, entrada, alta impedancia  HSPI_INT/PWM1/UART5_RTS/I2S_LRCL K/LCD_SEG25 50 PB_14 GPIO, entrada, alta impedancia  HSPI_CS/PWM2/LSPI_CS/I2S_DO/LCD_ SEG26 51 PB_15 GPIO, entrada, alta impedancia  HSPI_DI/PWM3/LSPI_CK/I2S_DI/LCD_ SEG27 52 PB_10 GPIO, entrada, alta impedancia  I2S_DI/MMC_D2/HSPI_DI/SDIO_D2/LC D_SEG22 53 VDD33IO Fuente de alimentaci\u00f3n IO, 3,3 V 54 PB_11 GPIO, entrada, alta impedancia  I2S_DO/MMC_D3/HSPI_DO/SDIO_D3/LCD_SEG23 55 PB_16 GPIO, entrada, alta impedancia  HSPI_DO/PWM4/LSPI_MISO/UART1_RX/LCD_SEG28 56 PB_17 GPIO, entrada, alta impedancia  UART5_RX/PWM_BREAK/LSPI_MOSI/I2S_MCLK/LCD_SEG29 5V INPUT 5V W801 GND GROUND CARD W801 3.3V INPUT 3.3V W801"},{"location":"repoFer/W801/quickref/#adc","title":"ADC","text":"<p>El m\u00f3dulo de adquisici\u00f3n basado en Sigma-Delta ADC completa la adquisici\u00f3n de hasta 4 se\u00f1ales anal\u00f3gicas. La frecuencia de muestreo se controla mediante un reloj de entrada externo. Puede recopilar el voltaje de entrada y la temperatura del chip, y admite calibraci\u00f3n de entrada y calibraci\u00f3n de compensaci\u00f3n de temperatura. </p>"},{"location":"repoFer/W801/quickref/#example","title":"Example:","text":""},{"location":"repoFer/W801/quickref/#include-arduinoh","title":"include \"Arduino.h\"","text":"<p>/  * HLK-W80x Analog read example.  *   * W80x boards has four analog ports.  * You can access it from Arduino code by pin numbers PA1-PA4  * or by short names A1-A4.  *   * Name A0 is alias to A1, added for compatibility.  *   /  int a1=PA4;  int a2=PB0;  int a3=PB1;</p> <p>void setup() { pinMode(a1,ANALOG_INPUT); pinMode(a2,OUTPUT); pinMode(a3,OUTPUT);  </p> <p>digitalWrite(a2,LOW); digitalWrite(a3,LOW);</p> <p>} void loop() { if (250&gt;=analogRead(a1)){ digitalWrite(a2,HIGH); digitalWrite(a3,LOW); } else { digitalWrite(a2,LOW); digitalWrite(a3,HIGH); }</p> <p>}</p>"},{"location":"repoFer/W801/quickref/#pwm","title":"PWM","text":"<p>Funci\u00f3n de generaci\u00f3n de se\u00f1al PWM de 5 canales </p> <p>Funci\u00f3n de captura de se\u00f1al de entrada de 2 canales (PWM0 y PWM4 dos canales) </p> <p>Rango de frecuencia: 3Hz ~ 160KHz </p> <p>Precisi\u00f3n m\u00e1xima del ciclo de trabajo: 1/256, ancho del contador insertado en la zona muerta: 8 bits </p>"},{"location":"repoFer/W801/quickref/#example_1","title":"Example:","text":""},{"location":"repoFer/W801/quickref/#include","title":"include","text":""},{"location":"repoFer/W801/quickref/#define-duty_max-240","title":"define DUTY_MAX 240","text":""},{"location":"repoFer/W801/quickref/#define-duty_min-50","title":"define DUTY_MIN 50 <p>// Note: on W801 board only two LEDs are connetcted to PWM pins, so PB5 led won't lit</p> <p>int m[3] = { 0 }, d[3] = { DUTY_MIN, (DUTY_MIN + DUTY_MAX) / 2, DUTY_MAX - 1 };</p> <p>int pwm_pin[3] = { LED_BUILTIN_1, LED_BUILTIN_2, LED_BUILTIN_3 };</p> <p>void setup() {   for (int i = 0; i &lt; 3; i++) pinMode(pwm_pin[i], PWM_OUT); }</p> <p>void loop() {</p> <p>for (int i = 0; i &lt; 3; i++) {     if (m[i] == 0)  // Increasing     {       analogWrite(pwm_pin[i], d[i]++);       if (d[i] == DUTY_MAX) m[i] = 1;     } else  // Decreasing     {       analogWrite(pwm_pin[i], d[i]--);       if (d[i] == DUTY_MIN) m[i] = 0;     }   } delay(5); }</p>","text":""},{"location":"repoFer/W801/quickref/#uart-communication","title":"UART communication","text":"<p>El lado del dispositivo cumple con el protocolo de interfaz de bus APB </p> <p>Admite modo de trabajo de interrupci\u00f3n o sondeo </p> <p>Admite el modo de transferencia DMA, existe FIFO de 32 bytes para enviar y recibir </p> <p>Velocidad de baudios programable </p> <p>Longitud de datos de 5-8 bits y paridad configurable </p> <p>1 o 2 bits de parada configurables </p> <p>Admite control de flujo RTS/CTS </p> <p>Admite env\u00edo y recepci\u00f3n de fotogramas interrumpidos </p> <p>Desbordamiento, error de paridad, error de trama, indicaci\u00f3n de interrupci\u00f3n de trama de ruptura de recepci\u00f3n </p> <p>Operaci\u00f3n DMA de 16 bytes en r\u00e1faga como m\u00e1ximo </p>"},{"location":"repoFer/W801/quickref/#example_2","title":"Example:","text":"<p>const int pin1 = PB21; const int pin2 = PB22;</p> <p>void setup() {   Serial.begin(115200);   pinMode(pin1, pin.OUTput);   pinMode(pin2, pin.OUTput); } void loop() {     Serial.println(\"\\r\\n Comunicacion UART tarjeta W801-PC:\");     Serial.println(\"\\r\\n Oprimiendo la letra Q, activa la salida  del pin1.\");</p> <p>if (Serial.available() &gt; 0) {     char command = Serial.read();</p> <pre><code>switch(command) {  \n   case 'Q':\n     digitalWrite(pin1, HIGH);\n     delay(4000); \n     digitalWrite(pin1, LOW);\n     delay(1000);\nbreak;\n\n   default:\n      digitalWrite(pin2, HIGH);\n      delay(4000);\n      digitalWrite(pin2, LOW);\n      delay(1000); \n    break;\n}\n</code></pre> <p>} }</p>"},{"location":"repoFer/W801/quickref/#programming-in-v-language","title":"Programming in v language","text":"<p>For each of these modules, you will have a file in .c.v format with the same name of the module and in this you will have the text module followed by the name of the module, example: * module pin * module adc * module pwm</p>"},{"location":"repoFer/W801/quickref/#output-port-configuration","title":"Output port configuration","text":"<p>To activate the port to use</p> <pre><code>pin.setup(pin_name, mode)\n</code></pre> <p>To activate the port to use</p> <pre><code>pin.high(PIN_NAME)\n</code></pre> <ul> <li>Example: If you want to activate the port 17;  <code>pin.high(17)</code>.</li> </ul> <p>To disable the port being used</p> <pre><code>pin.low(PIN_NAME)\n</code></pre> <ul> <li>Example: If you want to disable the port 17;  <code>pin.low(17)</code>.</li> </ul> <p>To disable or enable the port to be used</p> <pre><code>pin.write(PIN_NAME, VALUE)\n</code></pre> <ul> <li>Example: If you want to disable port 17 <code>pin.write(17, 1)</code>, and if you want to activate  <code>pin.write(17, 0)</code>.</li> </ul>"},{"location":"repoFer/W801/quickref/#analog-to-digital-ports-adc","title":"Analog to digital ports (ADC)","text":"<p>To configure one of the analog ports</p> <pre><code>adc.setup(PIN_NAME, SETUP_VALUE, ... )\n</code></pre> <ul> <li>In PIN_NAME the name of the analog port is entered, in SETUP_VALUE the VALUE that will be given is said port.</li> </ul> <p>To detect the analog port VALUE</p> <pre><code>x = adc.read(PIN_NAME)\n</code></pre> <ul> <li>In <code>PIN_NAME</code> the name of the analog port is entered, and <code>x</code> takes the VALUE of said port..</li> </ul>"},{"location":"repoFer/W801/quickref/#pulse-width-modulation-pwm-outputs","title":"Pulse Width Modulation (PWM outputs)","text":"<p>To configure some PWM</p> <pre><code>pwm.setup(SETUP_VALUE, setup_VALUE_1, ... )\n</code></pre> <ul> <li>In pwm you set the PWM to use, and in SETUP_VALUE the VALUE to which you want to configure said pwm.</li> </ul> <p>To configure the duty cycle of a modulator</p> <pre><code>pwm.write(duty)\n</code></pre> <ul> <li>In PWM the pwm to be used is set, and in <code>duty</code> the VALUE of the cycle (from 0 to 100) in percentage.</li> </ul>"},{"location":"repoFer/W801/quickref/#serial-communication-uart","title":"Serial communication (UART)","text":"<p>The UART used to be the standard stream output, so the functions <code>print()</code>, <code>println()</code> and <code>input()</code> work directly on the default UART. The default UART could change depending on the board or microcontroller, please refer to the specific documentation. The syntax for most of UART functions is: <code>uart_function_name_x()</code>, being <code>x</code> the identifying number in case of multiple UARTs. You can omit the <code>x</code> for referring to the first or default UART, or in the case of having only one.  </p>"},{"location":"repoFer/W801/quickref/#uart-setup","title":"UART setup","text":"<pre><code>uart.setup(BAUD_RATE)   // the same of uart.setup(BAUD_RATE)\n</code></pre> <p>For a second connection it is used as:</p> <pre><code>uart.setup_1(BAUD_RATE)   // the same of uart.setup_1(BAUD_RATE)\n</code></pre> <ul> <li><code>BAUD_RATE</code> configure the communication speed</li> </ul>"},{"location":"repoFer/W801/quickref/#serial-transmitting","title":"Serial transmitting","text":"<pre><code>uart.print(message)      // print a string to the default UART\n</code></pre> <pre><code>uart.println(message)    // print a string plus a line-new character to the default UART\n</code></pre> <pre><code>uart.ready // get everything ready for to UART\n</code></pre> <pre><code>uart.read // receives binary data (in Bytes) to UART\n</code></pre> <pre><code>uart.write(MESSAGE)    // send binary data (in Bytes) to second UART\n</code></pre> <ul> <li>For a second UART, it would be used as follows:</li> </ul> <pre><code>uart.print_1(MESSAGE)    // print a string to the second UART\n</code></pre> <pre><code>uart.println_1(MESSAGE)  // print a string plus a line-new character to the second UART\n</code></pre> <pre><code>uart.write_1(MESSAGE)    // send binary data (in Bytes) to second UART\n</code></pre> <pre><code>uart.ready_1 // get everything ready for to second UART\n</code></pre> <pre><code>uart.read_1 // receives binary data (in Bytes) to second UART\n</code></pre>"},{"location":"repoFer/W801/quickref/#retardos","title":"Retardos","text":"<ul> <li> <p>Use of times</p> <ul> <li>In each expression, the time VALUE is put inside the parentheses.</li> </ul> </li> </ul> <pre><code>time.sleep(S) //Seconds\n</code></pre> <pre><code>time.sleep_ms(MS) //Milliseconds\n</code></pre> <pre><code>time.sleep_us(US) //Microseconds\n</code></pre> <ul> <li>Example flashing LED</li> </ul> <pre><code>import pin\nimport time {sleep_ms}\n\npin.setup(14, pin.output)\n\nfor {   //infinite loop\n    pin.high(14)\n    sleep_ms(500)\n    pin.low(14)\n    sleep_ms(500)\n}\n</code></pre>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/","title":"Fast guide CH573F-mini-BLE","text":"<p>This Aixt implementation that supports the card  CH573F-mini-BLE</p>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#id-card-ch573f-mini-ble","title":"ID card CH573F-mini-BLE","text":""},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#view","title":"View","text":"<p>CH573F-mini-BLE, It's a card with Bluetooth 4.2 communication, featuring a total of 24 pins divided into two ports, A and B, with a speed of 60 MHz, 18 kB of RAM, 448 kB of ROM, with connection through USB type C. It includes output, input, PWM, ADC and UART functions.</p> <p></p> <p>Image taken from the device Image_CH573F-mini-BLE</p>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#datasheet","title":"Datasheet","text":"<p>CH573F-mini-BLE</p>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#port-identification","title":"Port Identification","text":"<p>Below are the ports used and their proper designations for programming:</p> Name Alternate Funcion Description G Ground 5V 5V Power supply G Ground 3V3 3.3V Power supply A4 I/0 General purpose bidirectional digital I/0 pin RXD3 A5 I/0 General purpose bidirectional digital I/0 pin TXD3 A8 I/0 General purpose bidirectional digital I/0 pin RXD1 A9 I/0 General purpose bidirectional digital I/0 pin TXD1 A10 I/0 General purpose bidirectional digital I/0 pin A11 I/0 General purpose bidirectional digital I/0 pin A12 I/0 General purpose bidirectional digital I/0 pin PWM4 A13 I/0 General purpose bidirectional digital I/0 pin PWM5 A14 I/0 General purpose bidirectional digital I/0 pin A15 I/0 General purpose bidirectional digital I/0 pin B4 I/0 General purpose bidirectional digital I/0 pin RXD0 PWM7 B7 I/0 General purpose bidirectional digital I/0 pin TXD0 PWM9 B10 I/0 General purpose bidirectional digital I/0 pin B11 I/0 General purpose bidirectional digital I/0 pin B12 I/0 General purpose bidirectional digital I/0 pin B13 I/0 General purpose bidirectional digital I/0 pin B14 I/0 General purpose bidirectional digital I/0 pin PWM10 B15 I/0 General purpose bidirectional digital I/0 pin B22 I/0 General purpose bidirectional digital I/0 pin RXD2 B23 I/0 General purpose bidirectional digital I/0 pin TXD2 PWM11"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#programming-in-cc-language","title":"Programming in C/C++ language","text":"<p>Programming of the CH573-mini-BLE card is done using the MounRiver Studio program, which is developed based on the Eclipse GNU version. It is optimized for integrated development of C/C++ for ARM and RISC-V processor microcontrollers, with the latter being present in the CH573-mini-BLE card.  </p>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#programming-in-v-language","title":"Programming in v language","text":"<p>The distribution will be by modules within the API according to the functions to be implemented on the CH573F-miniBLE card. The modules will have a specific configuration in the internal file created with the name of each module with the extension .c.v and other configuration files within the module for proper configuration of each function. The modules for the CH573-mini-BLE card are as follows:</p> <ul> <li>Module adc</li> <li>Module pin</li> <li>Module port</li> <li>Module pwm</li> <li>Module time</li> <li>Module uart</li> </ul>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#setup-pin-configuration","title":"Setup pin configuration","text":"<p>To configure the pin usage mode.</p> <pre><code>pin.setup(pin_name, mode)\n</code></pre> <ul> <li>Example: If you want to activate pin 11 of port A as an output;  <code>pin.setup(pin.a11, pin.output)</code>.</li> <li>Example: If you want to activate pin 11 of port A as an input.;  <code>pin.setup(pin.a11, pin.input)</code>.</li> </ul> <p>To activate the pin to use</p> <pre><code>pin.high(PIN_NAME)\n</code></pre> <ul> <li>Example: If you want to activate pin 7 of port B;  <code>pin.high(pin.b7)</code>.</li> </ul> <p>To disable the pin being used</p> <pre><code>pin.low(PIN_NAME)\n</code></pre> <ul> <li>Example: If you want to disable pin 7 of port B;  <code>pin.low(pin.b7)</code>.</li> </ul>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#setup-port-configuration","title":"Setup port configuration","text":"<p>To configure the mode of one or all pins of the specific port.</p> <pre><code>port.setup(PORT, BITS, MODE)\n</code></pre> <ul> <li>Example: If you want to activate pin 4 of port A as an output;  <code>pin.setup(pin.a, pin.0x00000010, output)</code>.</li> <li>Example: If you want to activate all pins of port B as inputs;  <code>pin.setup(pin.b, pin.0xFFFFFFFF, input)</code>.</li> </ul> <p>State port detection</p> <p>If you need to know what state an entry port is in:</p> <pre><code>pin.read(PORT)\n</code></pre> <ul> <li>Example: If you want to detect the VALUE of port A; <code>port.read(port.a)</code></li> </ul> <p>To activate one pin o all pin to use</p> <pre><code>port.write(PORT, BITS)\n</code></pre> <ul> <li>Example: If you want to activate pin 15 of port B as an output;  <code>port.write(port.b, 0x00000080)</code>.</li> <li>Example: If you want to activate all pins of port B;  <code>port.write(port.a, 0xFFFFFFFF)</code>.</li> </ul>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#pulse-width-modulation-pwm-outputs","title":"Pulse Width Modulation (PWM outputs)","text":"<p>There are 6 PWM channels on the CH573-mini-BLE card, each channel having its respective pin for output configuration. </p> <p>For PWM output configuration:</p> <pre><code>pwm.write(channel, value)\n</code></pre> <ul> <li>Example: If you  want activate pwm the channel 4 with specific value between a cycle of 0 and 256;  <code>pwm.write(4, 50)</code></li> </ul>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#serial-communication-uart","title":"Serial communication (UART)","text":"<p>For serial communication, the CH573-mini-BLE card has four UART ports, each port having two pins for sending and receiving data, TX and RX respectively. For serial communication, a USB-TTL cable with its respective driver must be used.</p> <p>Because there are four UART serial communication ports, the configuration in the API is created for each UART, establishing UART, UART1, UART2, and UART3.</p> <p>For configuring the UART serial communication speed: </p> <pre><code>uart#.setup(baud_rate)\n</code></pre> <ul> <li><code>baud_rate</code> to configure the serial communication speed.</li> <li>Example: If you want to establish a speed in UART0, you use <code>uart0.setup(115200)</code></li> </ul>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#serial-transmitting","title":"Serial transmitting","text":"<pre><code>uart#.print(message)      // print a string to the default UART\n</code></pre> <ul> <li>Example: If you want to use UART0 port <code>uart0.print(Uart for AIXT)</code></li> </ul> <pre><code>uart#.println(message)    // print a string plus a line-new character to the default UART\n</code></pre> <ul> <li>Example: If you want to use UART1 port <code>uart1.println(Command received)</code></li> </ul> <pre><code>uart#.write(message)    // send binary data (in Bytes) to the default UART\n</code></pre> <ul> <li>Example: If you want to use UART2 port <code>uart2.write()</code></li> </ul> <pre><code>uart#.read // receives binary data (in Bytes) to the default UART \n</code></pre> <ul> <li>Example: If you want to use UART3 port <code>uart3.read()</code></li> </ul>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#time","title":"Time","text":"<ul> <li>In each expression, the time VALUE is put inside the parentheses.</li> </ul> <pre><code>time.sleep(s) //Seconds\n</code></pre> <ul> <li>Example: This is used as <code>time.sleep(2)</code></li> </ul> <pre><code>time.sleep_ms(ms) //Milliseconds\n</code></pre> <ul> <li>Example: This is used as <code>time.sleep_ms(500)</code></li> </ul> <pre><code>time.sleep_us(us) //Microseconds\n</code></pre> <p>Example: This is used as <code>time.sleep_us(5000)</code></p>"},{"location":"repoFer/WCH/CH573F-mini-BLE/WCH/quickref/#implementation-of-the-aixt-project","title":"Implementation of the AIXT project","text":"<p>Below are some code in V language, examples of the main functions that are transcompiled to obtain the code in C/C++ language and perform the upload to the CH573F-mini-BLE card through the WCHISPTool extension of the MounRiver program. </p> <ul> <li>Example flashing LED</li> </ul> <pre><code>import time { sleep_ms }\nimport pin \n\npin.setup(pin.a8, pin.output)\n\nfor {\n    pin.high(pin.a8)    \n    sleep_ms(150)\n    pin.low(pin.a8)\n    sleep_ms(150)\n}\n</code></pre> <ul> <li>Example flashing LED with toggle </li> </ul> <pre><code>import time { sleep_ms }\nimport pin \n\npin.setup(pin.a8, pin.output)\n\nfor {\n    pin.toggle(pin.a8)    \n    sleep_ms(150)\n}\n</code></pre> <ul> <li>Example PORT </li> </ul> <pre><code>import port\nimport time {sleep_ms}\n\nport.setup(port.a, pin.0x00000800, port.output)\nport.setup(port.b, pin.0xFFFFFFFF, port.output)\nfor{\n    port.write(port.a,0x00000800)\n    time.sleep_ms(1000)\n    port.write(port.b,0x00000800)\n    time.sleep_ms(1000)\n}\n</code></pre> <ul> <li>Example PWM</li> </ul> <pre><code>import time { sleep_ms }\nimport pin { setup }                         \nimport pwm                           \n\npin.setup(pin.a12, pin.output) \n\nvalue := 50\n\nfor {\n    pwm.write(4, value)\n    value = value + 50\n    sleep_ms(300)\n    if value &gt; 250 {\n        pwm.off(4)  \n        sleep_ms(300)\n        value = 50 \n    }\n}\n</code></pre> <ul> <li>Example ADC</li> </ul> <pre><code>import pin { setup }                         \nimport pwm      \nimport adc\n\npin.setup(pin.a4, pin.input) \n\nadc.setup(0)\n\nfor {\n    adc.read(value)\n    pwm.write(4, value)\n    }\n</code></pre> <ul> <li>Example UART0</li> </ul> <pre><code>import time {sleep_ms}\nimport uart\nimport pin \n\npin.high(pin.b7)\npin.setup(pin.b4, in_pullup) \npin.setup(pin.b7, pin.output)\n\nuart.setup(115200)\n\nfor {\n    uart.write(TxBuff)\n    sleep_ms(2000)\n    uart.read()\n}\n</code></pre>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/","title":"QUICK GUIDE ESP32-C3FH4","text":"<p>This is an Aixt implementation to provide support for the ESP32-C3FH4 board.</p>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#summary","title":"SUMMARY","text":"<ul> <li> <p>The ESP32C3FH4 by WeAct Studio is a development board based on the ESP32-C3FH4 microcontroller from Espressif Systems. This microcontroller is part of the ESP32 family from Espressif, known for its low-power Wi-Fi and Bluetooth connectivity.</p> </li> <li> <p>The ESP32-C3FH4 is a low-cost, low-power microcontroller. It is based on a 32-bit RISC-V processor architecture and features dual-mode Wi-Fi connectivity and integrated Bluetooth technology.</p> </li> <li> <p>WeAct Studio is a manufacturer of development boards and electronic modules. The ESP32C3FH4 development board from WeAct Studio provides a convenient environment for working with the ESP32-C3FH4 microcontroller. It typically includes features such as input/output ports, antenna connectors, programming interfaces, and debugging capabilities, among others. </p> </li> </ul>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#function","title":"FUNCTION","text":"<ul> <li> <p>The functions of the ESP32C3FH4 from WeAct Studio are determined both by the capabilities of the ESP32-C3FH4 microcontroller and by the additional features provided by the WeAct Studio development board.</p> </li> <li> <p>The ESP32C3FH4 can utilize its analog and digital input pins to connect a variety of sensors, such as temperature, humidity, light, motion sensors, etc. This allows the creation of IoT devices that can collect data from the environment. In addition to reading sensor data, the ESP32C3FH4 can control output devices such as motors, relays, lights, among others. This enables system automation and the creation of interactive devices.</p> </li> <li> <p>The ESP32C3FH4 can communicate with other devices through serial ports, such as UART, SPI, and I2C. This allows integration with a wide variety of devices and peripherals.</p> </li> <li> <p>The ESP32-C3FH4 microcontroller offers integrated security features, such as data encryption and authentication, which are important for security-sensitive applications such as access control systems and medical devices.</p> </li> <li> <p>With low power consumption, ESP32-C3FH4 is an ideal choice for IoT (internet of thing) devices in the following areas; smart homes, industrial automation, healthcare, consumer electronics, smart agriculture, POS machines, service robots, audio devices, low-power IoT data loggers, low-power IoT sensor hubs.</p> </li> </ul>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#specs","title":"SPECS","text":"<ul> <li>32-bit RIsC-V single-core processor, up to 160Mhz.</li> <li>CoreMark score: <ul> <li>1 core at 160MHz: 407.22 CoreMark; 2.55 CoreMark/MHz.</li> </ul> </li> <li>384 KB ROM.</li> <li>400 KB SRAM (16 KB for cache).</li> <li>8 KB SRAM in RTC. </li> <li>Embedded flash.</li> <li>SPI, Dual SPI, Quad SPI and QPI interfaces that allow connection to multiple flash. </li> <li>Supports flash in.Circuit Programming (ICP).</li> <li>Digital interfaces: <ul> <li>3 x SPI.</li> <li>2 x UART.</li> <li>1 x I2C.</li> <li>1 x I2S.</li> <li>Remote control peripheral, with 2 transmit channels and 2 receive channels. </li> <li>LED PWM controller, with up to 6 channels. </li> <li>Full-speed USB Serial/JTAG controller. </li> <li>General DMA controller (GDMA), with 3 transmit channels and 3 receive channels.</li> </ul> </li> <li>Analog intefaces: <ul> <li>2 x 12-bit SAR ADCs, up to 6 channels. </li> </ul> </li> <li> <p>Timers: </p> <ul> <li>2 x 54-bit general-purpose timers.</li> <li>3 x digital watchdog timers. </li> <li>1 x analog watchdog timer.</li> <li>1 x 52-bit system timer. </li> </ul> </li> </ul>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#wifi","title":"WiFI","text":"<ul> <li>Supports 20 MHz, 40 MHz bandwidth in 2.4 GHz band.</li> <li>1T1R mode with data rate up to 150 Mbps. </li> <li>4 x virtual Wi-Fi interfaces. </li> </ul>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#bluetooth","title":"Bluetooth","text":"<ul> <li>Bluetooth LE: Bluetooth 5, Bluetooth mesh. </li> <li>High power mode (21 dBm).</li> <li>Speed: 125 Kbps, 500 Kbps, 1 Mbps, 2Mbps. </li> <li>Internal co-existence mechanism between Wi-Fi and Bluetooth to share the same antena. </li> </ul>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#datasheet","title":"DATASHEET","text":"<p>ESP32-C3_Series</p>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#pin-identification","title":"PIN IDENTIFICATION","text":"Pin No. Name Function 0 GPIO0; ADC1_0; XTAL_32K_P Analog; Digital; 1 GPIO1; ADC1_1; XTAL_32K_N Analog; Digital; 2 GPIO2; ADC1_2; FSPIQ; BOOT Analog; Digital; Fast Serial Peripheral Interface Quad-SPI; Booting. 3 GPIO3; ADC1_3; Analog; Digital. 4 GPIO4; ADC1_4; FSPHID; SCK; MTMS Analog; Digital; Full-Speed USB Human Interface Device; Serial Clock; Multi-Track Memory System. 5 GPI05; ADC2_0; FSPIWP; MISO; MTDI Analog; Digital; Full-Speed Serial Peripheral Interface Write Protect; Master In Slave Out; Microcontroller Test Data Input. 6 GPIO6; FSPICLK; MOSI; MTCK Digital; Full-Speed Serial Peripheral Interface Clock; Master Out Slave In; Microcontroller Test Clock. 7 GPI07; FSPID; SS; MTDO Digital; Full-Speed Serial Peripheral Interface Data; Slave Select; Microcontoller Test Data Output. 8 GPIO8; SDA; LOG; BULTIN LED Digital; Serial Data; Builtin LED. 9 GPIO9; SCL; BOOT Digital; Serial Clock Line; Booting. 10 GPIO10; FSPICSO; JTAG Digital; Full-Speed Serial Peripheral Interface Chip Select Output; Joint Test Action Group. 18 GPIO18; USB_D+ Digital; USB Conecction Dp. 19 GPI019; USB_D- Digital; USB Conecction Dn. 21 GPIO21; RXD 0 Digital; Serial Communication (Receiver) 22 GPIO22; TXD 0 Digital; Serial Communication (Transmitter) 5v Board Power Supply VB Voltage Boost GND Ground GND Ground GND Ground GND Ground 3.3v Microcontroller Power Supply 3.3v Microcontroller Power Supply EN Enable"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#programming-in-v-lenguaje","title":"PROGRAMMING IN V LENGUAJE","text":"Name Description <code>pin.setup(pin, mode)</code> Configure <code>pin</code> as <code>mode</code> (input, out) <code>pin.high(pin)</code> Digital output high <code>pin</code> <code>pin.low(pin)</code> Digital output low <code>pin</code> <code>pin.write(pin, val)</code> Write <code>val</code> to <code>pin</code> <code>pin.read(pin)</code> Digital read <code>pin</code> <code>adc.read(pin)</code> Analog read <code>pin</code> for <code>adc</code> <code>pwm.write(pin, val)</code> PWM output <code>pin</code> with duty cycle <code>val</code> <code>uart.setup(baud_rate)</code> Serial Communication initiation at <code>Baud_rate</code> <code>uart_any()</code> Get the number of byte to read <code>uart.read()</code> Serial Communication read <code>uart.println(\"message\")</code> Print <code>message</code> through Serial Communication <code>time.sleep(time)</code> Time delay in <code>sec</code> <code>time.sleep_us(time)</code> Time delay in <code>microsec</code> <code>time.sleep_ms(time)</code> Time delay in <code>milisec</code> <ul> <li>Description and compilation example on YouTube: https://youtu.be/dbCGMkhsr1E </li> </ul>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#examples","title":"EXAMPLES","text":"<p>Examples for transcompilation to C language, from AIXT</p>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#blinking","title":"BLINKING","text":"<pre><code>    import time { sleep_ms }            // Import the time module\n    import pin                          // Import the pin module \n\n    pin.setup(1, pin.output)            // Set pin #1 as output\n\n    for {\n        pin.high(1)                     // Output High\n        time.sleep_ms(1000)                 // Delay for 1s\n        pin.low(1)                      // Output Low \n        time.sleep_ms(1000)                 // Delay for 1s \n    }\n</code></pre>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#pwm-output","title":"PWM OUTPUT","text":"<pre><code> import time { sleep_ms }\nimport pin\nimport pwm\n\n__global (\n  val1 = 0\n  val2 = 0 \n  val3 = 0 \n)\n\npin.setup(1, pin.output)\npin.setup(4, pin.output)\npin.setup(10, pin.output)\n\nfor {\n    pwm.write(1, val1)\n    pwm.write(4, val2)\n    pwm.write(10, val3)\n    sleep_ms(500)\n    val1=val1+50\n    val2=val2+25\n    val3=val3+25\n    if val1==400 {\n          val1=0  \n    }\n\n    if val2 == 150 {\n        val2 = 0\n    }\n\n    if val3 == 100 {\n        val3 = 0\n    }\n} \n</code></pre>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#analog-reading","title":"ANALOG READING","text":"<pre><code>import pin                                \nimport adc                               \nimport pwm                               \n\n__global (\n    volumen = 0                          \n    )\n\nfor{                                      \n  volumen=adc.read(3)                      \n    pwm.write(7,volumen)                   \n}\n</code></pre>"},{"location":"repoFer/WeAct%20Studio/ESP32-C3FH4/quickref/#serial-communication","title":"SERIAL COMMUNICATION","text":"<pre><code>import pin             \nimport uart            \n\n __global(\n    button=0              \n )\n\n pin.setup(4, pin.output)\n uart.setup(9600)\n\n\nfor {                   \n\n    if pin.read(4) == 1  \n    { \n        button=button+1 \n        uart.print(button)\n    }\n}\n</code></pre>"},{"location":"repoFer/lib/","title":"Libraries documentation","text":"<p>In this folder is located the <code>.md</code> documentation files for the included libraries.</p>"},{"location":"repoFer/lib/oled/quickref/","title":"OLED","text":"<p>#  QUICK GUIDE OLED LIBRARY</p> <p>This is an implementation of a library dedicated to OLED screens, providing support for various microcontrollers.</p> <p>##  SUMMARY</p> <p>An OLED screen (Organic Light-Emitting Diode) is a type of display that uses organic diodes to emit light when an electric current is applied. Unlike LCD screens, OLEDs do not require backlighting, as each pixel lights up independently.</p> <p>The device supported by this library is based on the SSD1316 controller, which is designed to control monochromatic OLED screens, generally of small size. Its main features are:  </p> <ul> <li>Supported resolution up to 128x64 pixels.  </li> <li>Color mode: Monochromatic (white, blue, or yellow, depending on the OLED panel model).  </li> <li>Communication interface: Compatible with I2C and SPI, allowing flexible communication with various microcontrollers.  </li> <li>Low power consumption.  </li> <li>Integrated graphic controller: Enables drawing text and images without the need for external memory.  </li> </ul>"},{"location":"repoFer/lib/oled/quickref/#uses","title":"USES","text":"<p>OLED screens with the SSD1316 controller are widely used in electronic projects and embedded systems due to their low power consumption, high readability, and ease of integration.</p> <p>IoT Devices (Internet of Things)  Data visualization in temperature, humidity, pressure sensors, etc.  Energy consumption monitors in smart homes. * Control panels in automation systems.  </p> <p>Embedded Systems and Microcontrollers  Indicators in Arduino, ESP32, Raspberry Pi, STM32, etc.  Graphic interfaces for DIY or industrial projects. * Status monitors in robots and drones.  </p> <p>Wearables and Portable Devices  Smartwatches with low-power monochromatic displays.  Health monitoring devices (heart rate, blood oxygen, etc.).  </p> <p>Industrial and Measurement Equipment  Information displays in oscilloscopes, multimeters, and signal analyzers.  Operation indicators in 3D printers. * Interfaces in machinery control systems.  </p> <p>Home Appliances and Gadgets  Displays in coffee machines, air purifiers, and smart ovens.  Audio controls in amplifiers and equalizers. * Retro gaming consoles with monochromatic OLED screens.  </p>"},{"location":"repoFer/lib/oled/quickref/#supported-functions-for-transpilation","title":"SUPPORTED FUNCTIONS FOR TRANSPILATION**","text":"Functions in C Functions in V <code>display.begin (TYPE, ADDRESS)</code> <code>DISPLAY_SETUP (TYPE, ADDRESS)</code> <code>display.clearDisplay ()</code> <code>DISPLAY_CLEARDISPLAY ()</code> <code>display.setTextSize (NUMBERS)</code> <code>DISPLAY_SETTEXTSIZE (NUMBERS)</code> <code>display.setTextColor (CHARACTER)</code> <code>DISPLAY_SETTEXTCOLOR(CHARACTER)</code> <code>display.println (MESASAGE)</code> <code>DISPLAY_PRINTLN (MESSAGE)</code> <code>display.display ()</code> <code>DISPLAY_DISPLAY ()</code> <code>display.DrawPixel (X,Y,COLOR)</code> <code>DISPLAY_DRAWPIXEL(X,Y,COLOR)</code> <code>display.drawRect(X,Y,WIDTH,HEIGHT,COLOR)</code> <code>DISPLAY_DRAWRECT(X,Y,WIDTH,HEIGHT,COLOR)</code> <code>display.fillRect(X,Y,WIDTH,HEIGHT,COLOR)</code> <code>DISPLAY_FILLRECT(X,Y,WIDTH,HEIGHT,COLOR)</code> <code>display.drawCircle(X,Y,RADIO,COLOR)</code> <code>DISPLAY_DRAWCICRLE(X,Y,RADIO,COLOR)</code> <code>display.fillCircle(X,Y,RADIO,COLOR)</code> <code>DISPLAY_FILLCIRCLE(X,Y,RADIO,COLOR)</code> <code>display.drawBitmap(X,Y,ARRAY_IMAGE,WIDTH,HEIGHT,COLOR)</code> <code>DISPLAY_DRAWBITMAP(X,Y,ARRAY_IMAGE,WIDTH,HEIGHT,COLOR)</code> <p>Support Code for Functions in V Language </p> <pre><code>\n    fn C.DISPLAY_BEGIN(type_ any , address any) bool\n    fn C.DISPLAY_CLEARDISPLAY(any) \n    fn C.DISPLAY_SETTEXTSIZE(number any)\n    fn C.DISPLAY_TEXTCOLOR(character any)\n    fn C.DISPLAY_SETCURSOR(x any , y any)\n    fn C.DISPLAY_PRINTLN(message any)\n    fn C.DISPLAY_DISPLAY(any) \n    fn C.DISPLAY_DRAWPIXEL(x any , y any , color any)\n    fn C.DISPLAY_DRAWRECT(x any , y any , width any , height any , color any)\n    fn C.DISPLAY_FILLRECT(x any , y any , width any , height any , color any)\n    fn C.DISPLAY_DRAWCIRCLE(x any , y any , radio any , color any)\n    fn C.DISPLAY_FILLCIRCLE(x any , y any , radio any , color any) \n    fn C.DISPLAY_DRAWBITMAP(x any , y any , array_image any , width any , height any , color any)  \n\n</code></pre>"}]}